<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Savage Lands - Battle Simulator</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.9.0/ethers.umd.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; background: #000; color: #fff; overflow: hidden; }
        
        /* SCREENS */
        .screen { position: fixed; inset: 0; }
        .screen.hidden { display: none !important; }
        
        /* TITLE */
        .title-screen { 
            display: flex; flex-direction: column; align-items: center; 
            justify-content: center;
            gap: 30px;
            background: #000; 
            min-height: 100vh; 
            position: relative;
        }
        .title-video {
            max-width: 90%;
            max-height: 50vh;
            border: none;
            background: transparent;
        }
        .title-text { font-family: 'Press Start 2P', monospace; font-size: 36px; color: #FFD700; text-shadow: 0 0 20px #DC143C, 0 0 40px #000, 0 4px 0 #8B0000; position: relative; z-index: 1; letter-spacing: 4px; margin-bottom: 10px; }
        .title-btn { font-family: 'Press Start 2P', monospace; font-size: 14px; padding: 18px 40px; background: #DC143C; border: 3px solid #FFD700; color: #FFD700; cursor: pointer; position: relative; z-index: 1; }
        .title-btn:hover { background: #ff2020; transform: scale(1.05); }
        .title-sub { font-size: 11px; color: #888; margin-top: 20px; text-shadow: 0 0 10px #000; }
        .title-buttons { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; }
        
        /* Chest button - mimic on hover */
        .chest-btn {
            width: 80px;
            height: 80px;
            cursor: pointer;
            background: transparent;
            border: none;
            position: relative;
            transition: transform 0.2s;
        }
        .chest-btn:hover { transform: scale(1.1); }
        .chest-btn .chest-closed { display: block; width: 100%; height: 100%; object-fit: contain; }
        .chest-btn .chest-mimic { display: none; position: absolute; inset: 0; width: 100%; height: 100%; object-fit: contain; }
        .chest-btn:hover .chest-closed { display: none; }
        .chest-btn:hover .chest-mimic { display: block; }
        
        /* SELECT */
        .select-screen { display: flex; flex-direction: column; padding: 20px; background: #0a0a0a; overflow-y: auto; min-height: 100vh; position: relative; }
        .select-screen::before { content: ''; position: fixed; top: 0; left: 0; right: 0; height: 120px; background: url('assets/savage-lands-bg.jpg') center top / cover no-repeat; z-index: 0; pointer-events: none; }
        .select-screen::after { content: ''; position: fixed; bottom: 60px; left: 0; right: 0; height: 150px; background: url('assets/savage-lands-bg.jpg') center bottom / cover no-repeat; z-index: 0; pointer-events: none; }
        .select-screen > * { position: relative; z-index: 1; }
        .select-header { text-align: center; margin-bottom: 15px; }
        .select-title { font-family: 'Press Start 2P', monospace; font-size: 16px; color: #FFD700; margin-bottom: 10px; }
        .select-sub { font-size: 12px; color: #888; }
        .king-box { display: flex; align-items: center; gap: 15px; padding: 10px 20px; background: rgba(255,215,0,0.1); border: 2px solid #FFD700; margin-bottom: 10px; }
        .king-box h3 { font-family: 'Press Start 2P', monospace; font-size: 9px; color: #FFD700; margin: 0; white-space: nowrap; }
        .king-display { display: flex; align-items: center; gap: 10px; }
        .king-portrait { width: 50px; height: 50px; border-radius: 50%; border: 3px solid #FFD700; background: #222; overflow: hidden; flex-shrink: 0; }
        .king-portrait img { width: 100%; height: 100%; object-fit: cover; }
        .king-info { font-size: 10px; }
        .roster { display: grid; grid-template-columns: repeat(auto-fill, minmax(110px, 1fr)); gap: 10px; margin-bottom: 80px; flex: 1; }
        .roster-card { background: #1a1a1a; border: 2px solid #333; padding: 10px; text-align: center; cursor: pointer; }
        .roster-card:hover { border-color: #666; }
        .roster-card.selected { border-color: #32CD32; background: rgba(50,205,50,0.1); }
        .roster-card.king { border-color: #FFD700; background: rgba(255,215,0,0.2); box-shadow: 0 0 10px rgba(255,215,0,0.3); }
        .roster-card.general { border-color: #9932CC; background: rgba(153,50,204,0.15); }
        .roster-card.captain { border-color: #00CED1; background: rgba(0,206,209,0.1); }
        .roster-img { width: 80px; height: 80px; border-radius: 8px; margin: 0 auto 8px; background: #1a1a1a; overflow: hidden; border: 2px solid #333; }
        .roster-img img { width: 100%; height: 100%; object-fit: contain; image-rendering: pixelated; }
        .roster-name { font-size: 8px; color: #fff; margin-bottom: 2px; }
        .roster-role { font-size: 7px; color: #0ff; margin-bottom: 2px; }
        .roster-stats { font-size: 7px; color: #888; }
        .select-footer { position: fixed; bottom: 0; left: 0; right: 0; background: #111; border-top: 2px solid #8B0000; padding: 12px 20px; display: flex; justify-content: space-between; align-items: center; }
        .army-count { font-family: 'Press Start 2P', monospace; font-size: 10px; color: #FFD700; }
        .start-btn { font-family: 'Press Start 2P', monospace; font-size: 11px; padding: 12px 25px; background: #DC143C; border: 2px solid #FFD700; color: #FFD700; cursor: pointer; }
        .start-btn:disabled { opacity: 0.4; cursor: not-allowed; }
        
        /* ARENA - FULL SCREEN */
        .arena-screen { background: #000 !important; }
        #arena { position: absolute; top: 50px; left: 0; right: 0; bottom: 0; transition: transform 0.3s ease; transform-origin: center center; background: #000; }
        #arena.zoom-1x { transform: scale(1); }
        #arena.zoom-1-5x { transform: scale(1.5); }
        #arena.zoom-2x { transform: scale(2); }
        #arena.zoom-3x { transform: scale(3); }
        .zoom-controls { position: fixed; bottom: 80px; right: 10px; display: flex; flex-direction: column; gap: 5px; z-index: 200; }
        .zoom-btn { background: rgba(0,0,0,0.7); color: #fff; border: 1px solid #444; padding: 8px 12px; cursor: pointer; font-size: 14px; border-radius: 4px; }
        .zoom-btn:hover { background: rgba(50,50,50,0.9); }
        .zoom-btn.active { background: #4a4a00; border-color: #FFD700; }
        
        /* WALLS - solid barriers */
        .wall { position: absolute; background: linear-gradient(135deg, #3a3a3a 0%, #1a1a1a 100%); border: 2px solid #555; }
        /* Strongholds removed - pure arena combat */
        
        /* ITEMS - powerups that spawn in arena */
        .item {
            position: absolute;
            width: 28px; height: 28px;
            z-index: 8;
            cursor: pointer;
            animation: itemBob 1.5s ease-in-out infinite;
            filter: drop-shadow(0 0 8px rgba(255,255,255,0.5));
            will-change: transform;
        }
        .item-icon {
            width: 100%; height: 100%;
            display: flex; align-items: center; justify-content: center;
            font-size: 22px;
            background: rgba(0,0,0,0.5);
            border-radius: 6px;
            border: 2px solid rgba(255,255,255,0.3);
        }
        .item.item-health .item-icon { border-color: #ff4444; background: rgba(255,0,0,0.2); }
        .item.item-attack .item-icon { border-color: #ff8800; background: rgba(255,100,0,0.2); }
        .item.item-defense .item-icon { border-color: #4488ff; background: rgba(0,100,255,0.2); }
        .item.item-speed .item-icon { border-color: #44ff44; background: rgba(0,255,0,0.2); }
        .item.item-gold .item-icon { border-color: #ffd700; background: rgba(255,215,0,0.2); }
        .item.item-spell .item-icon { border-color: #aa44ff; background: rgba(150,0,255,0.2); }
        .item.item-chest .item-icon { border-color: #aa8844; background: rgba(150,100,50,0.2); }
        .item.picked { animation: itemPick 0.3s forwards; pointer-events: none; }
        @keyframes itemBob { 0%, 100% { transform: translate(-50%, -50%) scale(1); } 50% { transform: translate(-50%, -55%) scale(1.05); } }
        @keyframes itemPick { 0% { transform: translate(-50%, -50%) scale(1); opacity: 1; } 100% { transform: translate(-50%, -80%) scale(1.5); opacity: 0; } }
        
        /* FIGHTERS */
        .fighter { 
            position: absolute; 
            left: 0; top: 0;
            width: 32px; height: 32px; 
            cursor: pointer;
            z-index: 10;
            will-change: transform;
        }
        .fighter.king { width: 44px; height: 44px; z-index: 15; }
        .fighter-body {
            width: 100%; height: 100%;
            border-radius: 50%;
            border: 3px solid;
            overflow: hidden;
            background: #222;
        }
        .fighter.team0 .fighter-body { border-color: #32CD32; box-shadow: 0 0 6px rgba(50,205,50,0.6); }
        .fighter.team1 .fighter-body { border-color: #DC143C; box-shadow: 0 0 6px rgba(220,20,60,0.6); filter: hue-rotate(15deg) saturate(1.1); }
        
        /* Battle Cries - floating text */
        .battle-cry {
            position: absolute;
            font-family: 'Press Start 2P', monospace;
            font-size: 10px;
            color: #FFD700;
            text-shadow: 0 0 8px #000, 0 0 12px #FFD700, 2px 2px 0 #000;
            white-space: nowrap;
            pointer-events: none;
            z-index: 200;
            animation: battle-cry-float 2.5s ease-out forwards;
            transform: translate(-50%, -100%);
        }
        .battle-cry.rally { color: #32CD32; text-shadow: 0 0 8px #000, 0 0 12px #32CD32, 2px 2px 0 #000; }
        .battle-cry.command { color: #9932CC; text-shadow: 0 0 8px #000, 0 0 12px #9932CC, 2px 2px 0 #000; }
        .battle-cry.support { color: #00FFFF; text-shadow: 0 0 8px #000, 0 0 12px #00FFFF, 2px 2px 0 #000; }
        .battle-cry.threat { color: #DC143C; text-shadow: 0 0 8px #000, 0 0 12px #DC143C, 2px 2px 0 #000; }
        @keyframes battle-cry-float {
            0% { opacity: 1; transform: translate(-50%, -100%) scale(0.8); }
            20% { opacity: 1; transform: translate(-50%, -120%) scale(1.1); }
            100% { opacity: 0; transform: translate(-50%, -180%) scale(0.9); }
        }
        .fighter.inspected::before { 
            content: '‚ñº'; 
            position: absolute; 
            top: -24px; 
            left: 50%; 
            transform: translateX(-50%); 
            color: #FF0000; 
            font-size: 16px; 
            text-shadow: 0 0 8px #FF0000, 0 0 12px #FF0000; 
            z-index: 100;
            animation: pulse-marker 0.6s infinite alternate;
        }
        .fighter.king.inspected::before { top: -30px; }
        @keyframes pulse-marker { from { opacity: 0.7; transform: translateX(-50%) scale(0.9); } to { opacity: 1; transform: translateX(-50%) scale(1.1); } }
        .fighter.king .fighter-body { border-color: #FFD700 !important; box-shadow: inset 0 0 8px rgba(255,215,0,0.5); border-width: 4px; }
        .fighter-body img { width: 100%; height: 100%; object-fit: contain; image-rendering: pixelated; }
        .fighter.dead { opacity: 0.15; pointer-events: none; }
        .death-marker { position: absolute; pointer-events: none; z-index: 5; transform: translate(-50%, -50%); }
        .death-marker .skull { font-size: 16px; opacity: 0.7; }
        .death-marker .blood { position: absolute; width: 20px; height: 12px; background: radial-gradient(ellipse, #8B0000 0%, #4a0000 60%, transparent 100%); border-radius: 50%; top: 10px; left: 50%; transform: translateX(-50%); opacity: 0.6; }
        .fighter.invisible { opacity: 0.3; filter: blur(1px) hue-rotate(180deg); }
        .fighter-hp { position: absolute; top: -6px; left: 50%; transform: translateX(-50%); width: 30px; height: 4px; background: #111; border: 1px solid #000; }
        .fighter.king .fighter-hp { width: 40px; height: 5px; }
        .fighter-hp-fill { height: 100%; background: #32CD32; }
        .fighter-crown { position: absolute; top: -14px; left: 50%; transform: translateX(-50%); font-size: 12px; }
        .fighter-state { position: absolute; top: -18px; left: 50%; transform: translateX(-50%); font-size: 12px; pointer-events: none; }
        .fighter.king .fighter-state { top: -24px; }
        .fighter-mana { position: absolute; top: -2px; left: 50%; transform: translateX(-50%); width: 26px; height: 3px; background: #111; border: 1px solid #00f; }
        .fighter-mana-fill { height: 100%; background: #4169E1; }
        .fighter-shield { 
            position: absolute; 
            top: 50%; left: 50%; 
            width: 28px; height: 28px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            /* No transition - instant updates, no wild swinging */
        }
        .fighter-shield::before {
            content: '';
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            border: 3px solid rgba(70, 130, 180, 0.8);
            border-radius: 50%;
            clip-path: polygon(50% 50%, 100% 0%, 100% 100%);
        }
        .fighter.king .fighter-shield { width: 36px; height: 36px; }
        .fighter.king .fighter-shield::before { border-width: 4px; }
        /* Wounded pulse disabled for performance */
        
        /* ATTACK FX */
        /* Attack lines disabled for performance */
        .damage-num { position: absolute; font-family: 'Press Start 2P', monospace; font-size: 10px; color: #fff; text-shadow: 1px 1px 2px #000; pointer-events: none; animation: floatBounce 0.7s forwards; z-index: 100; transform: translate(-50%, -50%); }
        .damage-num.crit { color: #FFD700; font-size: 16px; text-shadow: 1px 1px 2px #000; animation: critPop 0.8s forwards; }
        .damage-num.heal { color: #32CD32; font-size: 12px; }
        .damage-num.buff { color: #00FFFF; font-size: 11px; }
        .damage-num.magic { color: #9932CC; font-size: 12px; }
        .damage-num.block { color: #4169E1; font-size: 10px; }
        .damage-num.riposte { color: #9370DB; font-size: 12px; }
        .damage-num.backstab { color: #FF00FF; font-size: 14px; text-shadow: 1px 1px 2px #000; animation: critPop 0.8s forwards; }
        .damage-num.lethal { color: #FF0000; font-size: 16px; text-shadow: 1px 1px 2px #000; animation: deathPop 1s forwards; }
        @keyframes floatBounce { 0% { transform: translate(-50%, -50%) scale(1.3); } 20% { transform: translate(-50%, -60%) scale(1); } 100% { transform: translate(-50%, -100%) scale(0.8); opacity: 0; } }
        @keyframes critPop { 0% { transform: translate(-50%, -50%) scale(0.5); } 30% { transform: translate(-50%, -50%) scale(1.5); } 100% { transform: translate(-50%, -120%) scale(0.7); opacity: 0; } }
        @keyframes deathPop { 0% { transform: translate(-50%, -50%) scale(0.5) rotate(-10deg); } 20% { transform: translate(-50%, -50%) scale(2) rotate(5deg); } 100% { transform: translate(-50%, -150%) scale(0.5); opacity: 0; } }
        @keyframes trophyBounce { 0% { transform: translateY(0) scale(1); } 100% { transform: translateY(-15px) scale(1.1); } }
        @keyframes cheerPulse { 0% { transform: translate(-50%, -50%) scale(1); } 100% { transform: translate(-50%, -50%) scale(1.05); text-shadow: 0 0 30px currentColor, 3px 3px 0 #000; } }
        
        /* HIT MARKERS & SPELL EFFECTS */
        .hit-marker { position: absolute; font-size: 16px; pointer-events: none; animation: hitPop 0.4s forwards; z-index: 80; transform: translate(-50%, -50%); }
        @keyframes hitPop { 0% { transform: translate(-50%, -50%) scale(1.5); opacity: 1; } 100% { transform: translate(-50%, -80%) scale(0.8); opacity: 0; } }
        .spell-cast { position: absolute; width: 24px; height: 24px; border-radius: 50%; pointer-events: none; animation: spellPulse 0.5s forwards; z-index: 60; transform: translate(-50%, -50%); border: 3px solid; }
        @keyframes spellPulse { 0% { transform: translate(-50%, -50%) scale(0.5); opacity: 1; } 100% { transform: translate(-50%, -50%) scale(2); opacity: 0; } }
        .spell-cast.fire { border-color: #FF4500; background: rgba(255,69,0,0.3); }
        .spell-cast.ice { border-color: #00BFFF; background: rgba(0,191,255,0.3); }
        .spell-cast.holy { border-color: #FFD700; background: rgba(255,215,0,0.3); }
        .spell-cast.shadow { border-color: #9932CC; background: rgba(153,50,204,0.3); }
        .spell-cast.nature { border-color: #32CD32; background: rgba(50,205,50,0.3); }
        
        /* SCREEN SHAKE */
        .arena-screen.shake { animation: screenShake 0.3s; }
        .arena-screen.bigShake { animation: bigScreenShake 0.5s; }
        @keyframes screenShake { 0%, 100% { transform: translateX(0); } 20% { transform: translateX(-5px); } 40% { transform: translateX(5px); } 60% { transform: translateX(-3px); } 80% { transform: translateX(3px); } }
        @keyframes bigScreenShake { 0%, 100% { transform: translateX(0); } 10% { transform: translate(-8px, 3px); } 30% { transform: translate(8px, -3px); } 50% { transform: translate(-6px, 2px); } 70% { transform: translate(6px, -2px); } 90% { transform: translate(-3px, 1px); } }
        
        /* FLASH EFFECTS */
        .fighter.hit { animation: hitFlash 0.15s; }
        .fighter.crit-hit { animation: critFlash 0.3s; }
        @keyframes hitFlash { 50% { filter: brightness(2) saturate(0); } }
        @keyframes critFlash { 0%, 100% { filter: brightness(1); } 25% { filter: brightness(3) hue-rotate(30deg); } 50% { filter: brightness(0.5); } 75% { filter: brightness(2); } }
        
        /* DRAGGABLE PANELS */
        .panel {
            position: absolute;
            background: rgba(10,10,10,0.95);
            border: 2px solid #8B0000;
            min-width: 200px;
            max-width: 400px;
            z-index: 500;
            font-size: 11px;
            display: flex;
            flex-direction: column;
            resize: both;
            overflow: hidden;
            min-height: 150px;
            max-height: 80vh;
        }
        #log-panel {
            width: 280px;
            height: 55vh;
        }
        .panel-header {
            background: #1a0a0a;
            padding: 8px 10px;
            cursor: move;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid #8B0000;
            user-select: none;
            flex-shrink: 0;
        }
        .panel-title { font-family: 'Press Start 2P', monospace; font-size: 9px; color: #DC143C; }
        .panel-btns { display: flex; gap: 5px; }
        .panel-btn { background: none; border: none; color: #888; cursor: pointer; font-size: 14px; }
        .panel-btn:hover { color: #fff; }
        .panel-content { padding: 10px; flex: 1; overflow-y: auto; min-height: 100px; }
        .panel.collapsed .panel-content { display: none; }
        .panel.collapsed { min-height: auto; resize: none; }
        
        /* LOG ENTRIES */
        .log-entry { padding: 4px 6px; margin-bottom: 3px; border-left: 2px solid #444; font-size: 9px; }
        .log-entry.kill { color: #DC143C; border-color: #DC143C; }
        .log-entry.king { color: #FFD700; border-color: #FFD700; font-size: 10px; }
        .log-entry.crit { color: #FF8C00; border-color: #FF8C00; }
        .log-entry.buff { color: #00FFFF; border-color: #00FFFF; }
        .log-entry.rout { color: #888800; border-color: #888800; }
        .log-entry.strike { color: #aaa; border-color: #666; }
        .log-entry.wound { color: #FF6B6B; border-color: #FF6B6B; }
        .log-entry.riposte { color: #9370DB; border-color: #9370DB; }
        .log-entry.block { color: #4169E1; border-color: #4169E1; }
        .log-entry.dodge { color: #32CD32; border-color: #32CD32; }
        .log-entry.rally { color: #FFD700; border-color: #DAA520; font-weight: bold; }
        .log-entry.magic { color: #9932CC; border-color: #9932CC; }
        
        /* INSPECTOR - DRAGGABLE/RESIZABLE PANEL */
        #insp-panel {
            display: none;
            left: 10px;
            top: 50px;
            width: 320px;
            min-width: 280px;
            max-width: 450px;
            max-height: none;
            border-width: 3px;
        }
        #insp-panel.open { display: flex; }
        #insp-content { padding: 10px; overflow-y: visible; }
        .insp-portrait { width: 220px; height: 220px; border-radius: 8px; margin: 0 auto 15px; overflow: hidden; background: transparent; }
        .insp-portrait img { width: 100%; height: 100%; object-fit: contain; image-rendering: pixelated; }
        .insp-name { text-align: center; font-family: 'Press Start 2P', monospace; font-size: 12px; margin-bottom: 8px; color: #fff; }
        .insp-role { text-align: center; font-size: 11px; color: #0ff; margin-bottom: 12px; }
        .insp-hp { height: 18px; background: #222; margin-bottom: 15px; position: relative; border: 1px solid #444; }
        .insp-hp-fill { height: 100%; }
        .insp-hp-text { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; font-size: 10px; font-weight: bold; }
        .insp-stats { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 10px; }
        .insp-stat { background: #1a1a1a; padding: 10px; text-align: center; border: 1px solid #333; }
        .insp-stat-val { color: #FFD700; font-size: 16px; font-weight: bold; }
        .insp-section { margin: 12px 0; padding: 10px; background: #111; border: 1px solid #333; }
        .insp-section-title { font-size: 9px; color: #888; margin-bottom: 8px; text-transform: uppercase; }
        
        /* TOP BAR */
        .top-bar { position: fixed; top: 0; left: 0; right: 0; height: 40px; background: rgba(0,0,0,0.8); border-bottom: 2px solid #8B0000; display: flex; justify-content: space-between; align-items: center; padding: 0 15px; z-index: 100; }
        /* MOMENTUM BAR - Tug of War */
        .momentum-section { display: flex; align-items: center; gap: 10px; flex: 1; max-width: 600px; }
        .momentum-label { font-family: 'Press Start 2P', monospace; font-size: 8px; white-space: nowrap; }
        .momentum-label.ally { color: #32CD32; }
        .momentum-label.enemy { color: #DC143C; }
        .momentum-track { flex: 1; height: 14px; background: linear-gradient(90deg, #1a3a1a 0%, #222 50%, #3a1a1a 100%); border: 2px solid #444; border-radius: 7px; position: relative; overflow: hidden; }
        .momentum-fill { position: absolute; top: 0; height: 100%; transition: left 0.5s ease-out, width 0.5s ease-out; }
        .momentum-fill.ally { background: linear-gradient(90deg, #32CD32, #228B22); left: 0; border-radius: 5px 0 0 5px; }
        .momentum-fill.enemy { background: linear-gradient(90deg, #8B0000, #DC143C); right: 0; border-radius: 0 5px 5px 0; }
        .momentum-indicator { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); width: 4px; height: 100%; background: #FFD700; transition: left 0.4s ease-out; z-index: 2; }
        .momentum-state { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-family: 'Press Start 2P', monospace; font-size: 7px; color: #FFD700; text-shadow: 0 0 4px #000, 0 0 8px #000; white-space: nowrap; z-index: 3; transition: opacity 0.3s; }
        .momentum-chevrons { position: absolute; top: 50%; transform: translateY(-50%); font-size: 10px; opacity: 0.7; animation: pulse-chevron 0.8s infinite; }
        .momentum-chevrons.left { left: 5px; color: #32CD32; }
        .momentum-chevrons.right { right: 5px; color: #DC143C; }
        @keyframes pulse-chevron { 0%, 100% { opacity: 0.4; } 50% { opacity: 1; } }
        .record { display: flex; gap: 10px; font-family: 'Press Start 2P', monospace; font-size: 10px; }
        .wins { color: #32CD32; }
        .losses { color: #DC143C; }
        .pause-btn { font-family: 'Press Start 2P', monospace; font-size: 10px; padding: 5px 15px; background: #222; border: 2px solid #444; color: #888; cursor: pointer; }
        .pause-btn:hover { border-color: #FFD700; color: #FFD700; }
        
        /* RESULT */
        .result-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.95); display: none; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; }
        .result-overlay.active { display: flex; }
        .result-title { font-family: 'Press Start 2P', monospace; font-size: 28px; margin-bottom: 20px; }
        .result-title.win { color: #32CD32; }
        .result-title.lose { color: #DC143C; }
        .result-stats { font-size: 12px; color: #888; margin-bottom: 20px; text-align: center; line-height: 1.8; }
        .result-btns { display: flex; gap: 15px; }
        .result-btn { font-family: 'Press Start 2P', monospace; font-size: 10px; padding: 12px 20px; background: #222; border: 2px solid #FFD700; color: #FFD700; cursor: pointer; }
        .result-btn:hover { background: #333; }
        
        .legends { margin-bottom: 20px; }
        .legends-title { font-family: 'Press Start 2P', monospace; font-size: 11px; color: #FFD700; margin-bottom: 10px; }
        .legends-grid { display: flex; gap: 10px; flex-wrap: wrap; justify-content: center; }
        .legend-card { background: #1a1a1a; border: 2px solid #333; padding: 8px; width: 90px; text-align: center; position: relative; cursor: pointer; transition: transform 0.2s; }
        .legend-card:hover { transform: translateY(-5px); border-color: #FFD700; }
        .legend-card.mvp { border-color: #FFD700; }
        .legend-tooltip { 
            display: none; position: absolute; bottom: 100%; left: 50%; transform: translateX(-50%); 
            background: rgba(10,10,20,0.95); border: 2px solid #FFD700; border-radius: 8px; 
            padding: 10px; min-width: 180px; z-index: 100; text-align: left; margin-bottom: 10px;
            box-shadow: 0 5px 20px rgba(0,0,0,0.5);
        }
        .legend-card:hover .legend-tooltip { display: block; }
        .legend-tooltip::after { content: ''; position: absolute; top: 100%; left: 50%; transform: translateX(-50%); border: 8px solid transparent; border-top-color: #FFD700; }
        .legend-tooltip-name { font-size: 11px; font-weight: bold; color: #FFD700; margin-bottom: 5px; text-align: center; }
        .legend-tooltip-role { font-size: 9px; color: #0ff; margin-bottom: 8px; text-align: center; }
        .legend-tooltip-stats { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; font-size: 9px; }
        .legend-tooltip-stat { background: #222; padding: 3px 6px; border-radius: 3px; }
        .legend-tooltip-stat span { color: #888; }
        .legend-tooltip-stat b { color: #FFD700; float: right; }
        .legend-img { width: 40px; height: 60px; border-radius: 6px; margin: 0 auto 5px; overflow: hidden; background: #1a1a1a; }
        .legend-img img { width: 100%; height: 100%; object-fit: contain; image-rendering: pixelated; }
        .legend-name { font-size: 7px; margin-bottom: 2px; }
        .legend-award { font-size: 6px; color: #0ff; margin-bottom: 2px; }
        .legend-stat { font-size: 9px; color: #FFD700; }
        /* Global wallet widget */
        .wallet-widget {
            position: fixed;
            top: 50px;
            right: 10px;
            z-index: 9999;
            display: flex;
            align-items: center;
            gap: 10px;
            background: rgba(0,0,0,0.8);
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid #4169E1;
        }
        .wallet-widget button {
            font-family: 'Press Start 2P', monospace;
            font-size: 8px;
            padding: 6px 10px;
            background: #4169E1;
            border: 2px solid #FFD700;
            color: #FFD700;
            cursor: pointer;
        }
        .wallet-widget button:hover { background: #5179F1; }
        .wallet-widget .status { font-size: 9px; color: #888; }
        .wallet-widget .status.connected { color: #32CD32; }
    </style>
</head>
<body>
    <!-- Global Wallet Widget -->
    <div class="wallet-widget" id="wallet-widget">
        <span id="wallet-status" class="status"></span>
        <button id="connect-wallet-btn" onclick="walletState.connected ? disconnectWallet() : connectWallet()">üîó Connect</button>
    </div>
    
    <div class="screen title-screen" id="title-screen">
        <div class="title-text">‚öîÔ∏è SAVAGE ARENA ‚öîÔ∏è</div>
        <video class="title-video" autoplay loop muted playsinline>
            <source src="assets/arena-cover.mp4" type="video/mp4">
        </video>
        <button class="chest-btn" onclick="goSelect()" title="Enter the Arena!">
            <img class="chest-closed" src="assets/chest-closed.gif" alt="Enter Battle">
            <video class="chest-mimic" autoplay loop muted playsinline>
                <source src="assets/chest-mimic.mp4" type="video/mp4">
            </video>
        </button>
        <div class="title-sub" style="color:#FFD700;font-family:'Press Start 2P',monospace;font-size:10px;">‚öîÔ∏è ENTER BATTLE ‚öîÔ∏è</div>
    </div>
    
    <!-- FAQ Modal -->
    <div id="faq-modal" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,0.9);z-index:1000;padding:40px;overflow-y:auto;">
        <div style="max-width:800px;margin:0 auto;background:#111;border:3px solid #FFD700;padding:30px;font-size:14px;color:#ddd;">
            <h2 style="font-family:'Press Start 2P',monospace;color:#FFD700;font-size:20px;margin-bottom:20px;">‚öîÔ∏è FAQ ‚öîÔ∏è</h2>
            <p><b style="color:#FFD700;">What is Savage Arena?</b><br>A 15v15 tactical battle where you build an army and fight for glory!</p>
            <p><b style="color:#FFD700;">How do I play?</b><br>Select your King + 14 warriors, then watch them fight in real-time tactical combat. Press SPACEBAR to pause!</p>
            <p><b style="color:#FFD700;">How do I win?</b><br>Eliminate the enemy army or break their morale. Protect your King - if they fall, morale crashes!</p>
            <p><b style="color:#FFD700;">What do the roles do?</b><br>
            ‚Ä¢ <span style="color:#32CD32;">Tank</span> - High HP, protects allies<br>
            ‚Ä¢ <span style="color:#DC143C;">Berserker</span> - High damage, rage when hurt<br>
            ‚Ä¢ <span style="color:#9932CC;">Mage</span> - Ranged spells, AoE damage<br>
            ‚Ä¢ <span style="color:#4169E1;">Rogue</span> - Stealth, backstabs<br>
            ‚Ä¢ <span style="color:#32CD32;">Cleric</span> - Heals and buffs allies<br>
            ‚Ä¢ <span style="color:#FFD700;">Paladin</span> - Holy warrior, tank + healer hybrid<br>
            ‚Ä¢ <span style="color:#556B2F;">Necromancer</span> - Raises the dead (max 2)<br>
            ‚Ä¢ <span style="color:#DAA520;">Bard</span> - Inspires allies, mocks enemies</p>
            <button class="title-btn" style="margin-top:20px;" onclick="hideFAQ()">CLOSE</button>
        </div>
    </div>
    
    <div class="screen select-screen hidden" id="select-screen">
        <div class="select-header">
            <div class="select-title">‚öîÔ∏è BUILD YOUR ARMY ‚öîÔ∏è</div>
            <div class="select-sub">Pick: üëë King ‚Üí ‚≠ê General ‚Üí üéñÔ∏è 3 Captains ‚Üí ‚öîÔ∏è 10 Army</div>
            <div id="nft-section" style="display:none;margin-top:10px;padding:10px;background:rgba(65,105,225,0.2);border:2px solid #4169E1;border-radius:8px;">
                <div style="font-size:11px;color:#4169E1;margin-bottom:8px;">üé® YOUR CHIMERAS (click to add to army)</div>
                <div id="nft-roster" style="display:flex;gap:8px;flex-wrap:wrap;"></div>
            </div>
        </div>
        <div class="king-box">
            <h3>üëë YOUR KING</h3>
            <div class="king-display">
                <div class="king-portrait" id="king-img"></div>
                <div class="king-info" id="king-info">Select a warrior</div>
            </div>
        </div>
        <div class="roster" id="roster"></div>
        <div class="select-footer">
            <div class="army-count" id="army-count">King: ‚Äî | Army: 0/14</div>
            <div style="display:flex;gap:10px;flex-wrap:wrap;justify-content:center;">
                <button class="start-btn" style="background:#8B4513;font-size:10px;padding:10px 15px;" onclick="shuffleRoster()">üîÑ NEW ROSTER</button>
                <button class="start-btn" style="background:#444;font-size:10px;padding:10px 15px;" onclick="randomFill()">üé≤ RANDOM FILL</button>
                <button class="start-btn" style="background:#228B22;font-size:10px;padding:10px 15px;" onclick="quickStart()">‚ö° QUICK START</button>
                <button class="start-btn" id="start-btn" onclick="startBattle()" disabled>SELECT ARMY</button>
            </div>
        </div>
    </div>
    
    <div class="screen arena-screen hidden" id="arena-screen">
        <div class="top-bar">
            <div class="momentum-section">
                <div class="momentum-label ally"><span id="m0">100%</span></div>
                <div class="momentum-track">
                    <div class="momentum-fill ally" id="m0bar" style="width:50%"></div>
                    <div class="momentum-fill enemy" id="m1bar" style="width:50%;left:50%"></div>
                    <div class="momentum-indicator" id="momentum-needle"></div>
                    <div class="momentum-chevrons left" id="chevrons-left" style="display:none">‚óÄ‚óÄ</div>
                    <div class="momentum-chevrons right" id="chevrons-right" style="display:none">‚ñ∂‚ñ∂</div>
                    <div class="momentum-state" id="momentum-state">EVEN</div>
                </div>
                <div class="momentum-label enemy"><span id="m1">100%</span></div>
            </div>
            <div class="record" id="battle-title" style="font-family:'Press Start 2P',monospace;font-size:9px;color:#FFD700;">‚öîÔ∏è SAVAGE ARENA ‚öîÔ∏è</div>
            <button class="pause-btn" id="pause-btn" onclick="togglePause()">‚è∏Ô∏è</button>
        </div>
        <div id="arena"></div>
        
        <div class="panel" id="log-panel" style="right:10px;bottom:10px;top:auto;">
            <div class="panel-header">
                <span class="panel-title">üìú BATTLE LOG</span>
                <div class="panel-btns">
                    <button class="panel-btn" onclick="togglePanel('log-panel')">_</button>
                </div>
            </div>
            <div class="panel-content" id="log-content"></div>
        </div>
        
        <!-- DRAGGABLE INSPECTOR PANEL -->
        <div class="panel" id="insp-panel">
            <div class="panel-header">
                <span class="panel-title">üîç FIGHTER</span>
                <div class="panel-btns">
                    <button class="panel-btn" onclick="togglePanel('insp-panel')">_</button>
                    <button class="panel-btn" onclick="closeInspector()">‚úï</button>
                </div>
            </div>
            <div class="panel-content" id="insp-content">
                <div style="text-align:center;color:#666;padding:20px;">Click a fighter to inspect</div>
            </div>
        </div>
        
        <!-- Zoom Controls -->
        <div class="zoom-controls" id="zoom-controls">
            <button class="zoom-btn active" onclick="setZoom(1)" data-zoom="1">1x</button>
            <button class="zoom-btn" onclick="setZoom(1.5)" data-zoom="1.5">1.5x</button>
            <button class="zoom-btn" onclick="setZoom(2)" data-zoom="2">2x</button>
            <button class="zoom-btn" onclick="setZoom(3)" data-zoom="3">3x</button>
        </div>
    </div>
    
    <div class="result-overlay" id="result">
        <div class="result-title" id="result-title">VICTORY</div>
        <div class="result-stats" id="result-stats"></div>
        <div class="legends" id="legends"></div>
        <div class="result-btns">
            <button class="result-btn" onclick="goSelect()">NEW ARMY</button>
            <button class="result-btn" onclick="startBattle()">REMATCH</button>
        </div>
    </div>

<script>
// Legacy IPFS (disabled - using local sprites now)
// const IPFS = 'https://gateway.pinata.cloud/ipfs/bafybeigidp6pel576xbmcdns5epgq5ivhkmss7vijfqvjztz2j7s5shdoa';

// Local tribal sprites - mapped by role
const SPRITE_PATH = 'sprites/processed';
const ROLE_SPRITES = {
    'Tank': 'Bearkin_16x32.png',
    'Berserker': 'Minotaur_16x32.png',
    'Mage': 'Salamander_16x32.png',
    'Rogue': 'Black_Ratman_16x32.png',
    'Cleric': 'Albino_Crocodillian_16x32.png',
    'Necromancer': 'White_Ratman_16x32.png',
    'Bard': 'Frogfolk_16x32.png',
    'Paladin': 'Lizardman_16x32.png',
    // Fallback sprites for variety
    'default': ['Crocodillian_16x32.png', 'Raccoon_16x32.png', 'Possum_16x32.png', 'Brown_Ratman_16x32.png', 'Winter_Bearkin_16x32.png', 'Poisonous_Frogfolk_16x32.png']
};

// Get sprite URL for a fighter
function getSpriteUrl(fighter) {
    if (ROLE_SPRITES[fighter.role]) {
        return `${SPRITE_PATH}/${ROLE_SPRITES[fighter.role]}`;
    }
    // Use fighter ID to pick a consistent fallback sprite
    const fallbacks = ROLE_SPRITES['default'];
    return `${SPRITE_PATH}/${fallbacks[fighter.id % fallbacks.length]}`;
}

// Gear templates by role
const GEAR = {
    Tank: {weapon:'‚öîÔ∏è Longsword', armor:'üõ°Ô∏è Plate Mail', accessory:'üíç Ring of Fortitude'},
    Berserker: {weapon:'ü™ì Battle Axe', armor:'ü¶∫ Chain Mail', accessory:'üíÄ Skull Charm'},
    Mage: {weapon:'ü™Ñ Staff', armor:'üß• Mystic Robes', accessory:'üìø Arcane Amulet'},
    Rogue: {weapon:'üó°Ô∏è Daggers', armor:'ü•∑ Shadow Cloak', accessory:'üé≠ Mask of Deception'},
    Cleric: {weapon:'üî± Holy Mace', armor:'‚ö™ Sacred Vestments', accessory:'‚ú® Divine Symbol'},
    Paladin: {weapon:'‚öîÔ∏è Holy Blade', armor:'üõ°Ô∏è Sacred Plate', accessory:'‚úùÔ∏è Divine Aegis'}
};

// Master roster - loaded from JSON, randomized each session
let FIGHTERS = [
    {id:1,name:"Crocus III",hp:380,atk:22,def:14,spd:0.9,role:"Tank",trait:"Stalwart"},
    {id:2,name:"Frostfang",hp:290,atk:28,def:8,spd:1.1,role:"Berserker",trait:"Frenzy"},
    {id:3,name:"Flamekeeper",hp:250,atk:24,def:10,spd:0.85,role:"Mage",trait:"Pyromancer"},
    {id:4,name:"Destroyer",hp:340,atk:25,def:12,spd:1.0,role:"Berserker",trait:"Rage"},
    {id:5,name:"Venomous",hp:320,atk:26,def:11,spd:1.25,role:"Rogue",trait:"Poison"},
    {id:6,name:"Boulderback",hp:420,atk:18,def:18,spd:0.7,role:"Tank",trait:"Ironclad"},
    {id:7,name:"Stormcaller",hp:240,atk:30,def:6,spd:0.9,role:"Mage",trait:"Lightning"},
    {id:8,name:"Thornhide",hp:360,atk:20,def:16,spd:0.8,role:"Tank",trait:"Thorns"},
    {id:9,name:"Shadowdancer",hp:260,atk:32,def:5,spd:1.4,role:"Rogue",trait:"Evasion"},
    {id:10,name:"Ironjaw",hp:400,atk:24,def:15,spd:0.75,role:"Tank",trait:"Unbreakable"},
    {id:11,name:"Blazefury",hp:280,atk:35,def:4,spd:1.2,role:"Berserker",trait:"Bloodlust"},
    {id:12,name:"Voidwalker",hp:220,atk:28,def:8,spd:1.0,role:"Mage",trait:"Dark Magic"},
    {id:13,name:"Bonecrusher",hp:380,atk:26,def:13,spd:0.85,role:"Berserker",trait:"Brutal"},
    {id:14,name:"Lightbringer",hp:300,atk:18,def:12,spd:0.9,role:"Cleric",trait:"Blessed"},
    {id:15,name:"Dreadnought",hp:450,atk:16,def:20,spd:0.6,role:"Tank",trait:"Colossus"},
    {id:16,name:"Whisperwind",hp:240,atk:22,def:7,spd:1.5,role:"Rogue",trait:"Swift"},
    {id:17,name:"Emberheart",hp:260,atk:26,def:9,spd:1.0,role:"Mage",trait:"Burning"},
    {id:18,name:"Grimfang",hp:340,atk:28,def:10,spd:1.05,role:"Berserker",trait:"Savage"},
    {id:19,name:"Seraphim",hp:280,atk:20,def:14,spd:0.95,role:"Cleric",trait:"Divine"},
    {id:20,name:"Nightstalker",hp:250,atk:34,def:4,spd:1.35,role:"Rogue",trait:"Assassin"},
    {id:21,name:"Titanfall",hp:440,atk:20,def:18,spd:0.65,role:"Tank",trait:"Giant"},
    {id:22,name:"Frostweaver",hp:230,atk:27,def:7,spd:0.9,role:"Mage",trait:"Frost"},
    {id:23,name:"Rageclaw",hp:320,atk:30,def:8,spd:1.15,role:"Berserker",trait:"Berserk"},
    {id:24,name:"Divine Aegis",hp:350,atk:16,def:16,spd:0.8,role:"Cleric",trait:"Guardian"},
    {id:25,name:"Phantom",hp:220,atk:36,def:3,spd:1.45,role:"Rogue",trait:"Ghost"},
    {id:26,name:"Earthshaker",hp:400,atk:22,def:17,spd:0.7,role:"Tank",trait:"Quake"},
    {id:27,name:"Infernus",hp:270,atk:32,def:5,spd:1.0,role:"Mage",trait:"Hellfire"},
    {id:28,name:"Bloodreaver",hp:300,atk:34,def:6,spd:1.2,role:"Berserker",trait:"Vampiric"},
    {id:29,name:"Sanctuary",hp:320,atk:14,def:15,spd:0.85,role:"Cleric",trait:"Protector"},
    {id:30,name:"Viper",hp:240,atk:30,def:6,spd:1.4,role:"Rogue",trait:"Venomous"},
    {id:31,name:"Warsong",hp:260,atk:16,def:10,spd:1.0,role:"Bard",trait:"Inspiring"},
    {id:32,name:"Drumcaller",hp:240,atk:14,def:8,spd:0.95,role:"Bard",trait:"Rhythmic"},
    {id:33,name:"Silvervice",hp:280,atk:18,def:12,spd:1.05,role:"Bard",trait:"Mockery"},
    {id:34,name:"Echobane",hp:250,atk:20,def:9,spd:1.1,role:"Bard",trait:"Dissonant"},
    {id:35,name:"Bonelord",hp:220,atk:22,def:6,spd:0.85,role:"Necromancer",trait:"Summoner"},
    {id:36,name:"Gravecaller",hp:240,atk:20,def:8,spd:0.9,role:"Necromancer",trait:"Reanimator"},
    {id:37,name:"Soulreaper",hp:200,atk:26,def:5,spd:0.95,role:"Necromancer",trait:"Harvester"},
    {id:38,name:"Plaguebringer",hp:260,atk:18,def:10,spd:0.8,role:"Necromancer",trait:"Blighted"},
    // PALADINS - Holy warriors, tank/support hybrid
    {id:39,name:"Valorheart",hp:360,atk:22,def:15,spd:0.85,role:"Paladin",trait:"Righteous"},
    {id:40,name:"Dawnbreaker",hp:340,atk:24,def:14,spd:0.9,role:"Paladin",trait:"Radiant"},
    {id:41,name:"Crusader",hp:380,atk:20,def:16,spd:0.8,role:"Paladin",trait:"Zealot"},
    {id:42,name:"Oathkeeper",hp:350,atk:23,def:15,spd:0.85,role:"Paladin",trait:"Holy"}
];

let state = { king: null, general: null, captains: [], army: [], wins: 0, losses: 0, match: null, paused: false, inspected: null };

// === WALLET & NFT INTEGRATION ===
const HEAVY_META_CONTRACT = '0x767fb91a98261aef823d46a5fb54b822cff24c03';
const BASE_CHAIN_ID = 8453;
let walletState = { connected: false, address: null, ownedTokens: [], nftFighters: [] };
let nftMetadata = null; // Will load the full metadata.json

// ERC721 ABI (minimal for reading)
const ERC721_ABI = [
    'function balanceOf(address owner) view returns (uint256)',
    'function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)',
    'function tokenURI(uint256 tokenId) view returns (string)',
    'function totalSupply() view returns (uint256)'
];

// Load full metadata
async function loadNFTMetadata() {
    if (nftMetadata) return nftMetadata;
    try {
        const res = await fetch('metadata.json');
        nftMetadata = await res.json();
        console.log(`‚úÖ Loaded metadata for ${nftMetadata.length || Object.keys(nftMetadata).length} NFTs`);
        return nftMetadata;
    } catch (e) {
        console.error('Failed to load metadata:', e);
        return null;
    }
}

// Connect wallet
async function connectWallet() {
    if (!window.ethereum) {
        alert('Please install MetaMask or another Web3 wallet!');
        return false;
    }
    
    try {
        // Request account access
        const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
        walletState.address = accounts[0];
        
        // Check/switch to Base
        const chainId = await window.ethereum.request({ method: 'eth_chainId' });
        if (parseInt(chainId, 16) !== BASE_CHAIN_ID) {
            try {
                await window.ethereum.request({
                    method: 'wallet_switchEthereumChain',
                    params: [{ chainId: '0x2105' }] // 8453 in hex
                });
            } catch (switchError) {
                // Chain not added, add it
                if (switchError.code === 4902) {
                    await window.ethereum.request({
                        method: 'wallet_addEthereumChain',
                        params: [{
                            chainId: '0x2105',
                            chainName: 'Base',
                            nativeCurrency: { name: 'ETH', symbol: 'ETH', decimals: 18 },
                            rpcUrls: ['https://mainnet.base.org'],
                            blockExplorerUrls: ['https://basescan.org']
                        }]
                    });
                }
            }
        }
        
        walletState.connected = true;
        updateWalletUI();
        
        // Load owned NFTs
        await loadOwnedNFTs();
        
        return true;
    } catch (e) {
        console.error('Wallet connect failed:', e);
        alert('Failed to connect wallet: ' + e.message);
        return false;
    }
}

// Load NFTs owned by connected wallet
async function loadOwnedNFTs() {
    if (!walletState.address) return;
    
    const statusEl = document.getElementById('wallet-status');
    if (statusEl) statusEl.textContent = 'üîç Loading your Chimeras...';
    
    try {
        const provider = new ethers.BrowserProvider(window.ethereum);
        const contract = new ethers.Contract(HEAVY_META_CONTRACT, ERC721_ABI, provider);
        
        // Get balance
        const balance = await contract.balanceOf(walletState.address);
        const numOwned = Number(balance);
        console.log(`üé® Wallet owns ${numOwned} HEAVY META NFTs`);
        
        if (numOwned === 0) {
            if (statusEl) statusEl.textContent = `üîó ${walletState.address.slice(0,6)}...${walletState.address.slice(-4)} (0 Chimeras)`;
            walletState.ownedTokens = [];
            return;
        }
        
        // Get token IDs
        walletState.ownedTokens = [];
        for (let i = 0; i < numOwned; i++) {
            const tokenId = await contract.tokenOfOwnerByIndex(walletState.address, i);
            walletState.ownedTokens.push(Number(tokenId));
        }
        console.log('üì¶ Owned token IDs:', walletState.ownedTokens);
        
        // Load metadata and create fighters
        await loadNFTMetadata();
        walletState.nftFighters = walletState.ownedTokens.map(tokenId => createFighterFromNFT(tokenId));
        
        if (statusEl) statusEl.textContent = `üîó ${walletState.address.slice(0,6)}...${walletState.address.slice(-4)} (${numOwned} Chimeras!)`;
        
        // Refresh roster to show NFT fighters
        renderRoster();
        
    } catch (e) {
        console.error('Failed to load NFTs:', e);
        if (statusEl) statusEl.textContent = '‚ùå Failed to load NFTs';
    }
}

// Create a fighter from NFT metadata
function createFighterFromNFT(tokenId) {
    // Find metadata for this token (array index = tokenId - 1 or search by tokenId)
    let meta = null;
    if (Array.isArray(nftMetadata)) {
        meta = nftMetadata.find(m => m.tokenId === tokenId || m.edition === tokenId) || nftMetadata[tokenId - 1];
    } else if (nftMetadata && nftMetadata[tokenId]) {
        meta = nftMetadata[tokenId];
    }
    
    if (!meta) {
        console.warn(`No metadata for token ${tokenId}`);
        return null;
    }
    
    // Extract traits
    const attrs = meta.attributes || [];
    const getAttr = (name) => attrs.find(a => a.trait_type === name)?.value || null;
    
    const body = getAttr('Body') || getAttr('Creature') || 'Chimera';
    const background = getAttr('Background') || 'Base';
    const weapon = getAttr('Weapon') || getAttr('Right Hand');
    const armor = getAttr('Armor') || getAttr('Torso');
    const accessory = getAttr('Accessory') || getAttr('Head');
    
    // Map traits to stats
    const roleMap = {
        // Bodies -> roles
        'Bearkin': 'Tank', 'Bear': 'Tank', 'Turtle': 'Tank',
        'Minotaur': 'Berserker', 'Bull': 'Berserker', 'Wolf': 'Berserker',
        'Salamander': 'Mage', 'Dragon': 'Mage', 'Phoenix': 'Mage',
        'Ratman': 'Rogue', 'Rat': 'Rogue', 'Snake': 'Rogue',
        'Frogfolk': 'Bard', 'Frog': 'Bard',
        'Crocodillian': 'Cleric', 'Croc': 'Cleric',
        'Lizardman': 'Paladin', 'Lizard': 'Paladin'
    };
    
    // Try to match body to role
    let role = 'Berserker'; // Default
    for (const [key, val] of Object.entries(roleMap)) {
        if (body.toLowerCase().includes(key.toLowerCase())) {
            role = val;
            break;
        }
    }
    
    // Base stats by role
    const baseStats = {
        Tank: { hp: 380, atk: 20, def: 16, spd: 0.75 },
        Berserker: { hp: 300, atk: 30, def: 8, spd: 1.1 },
        Mage: { hp: 240, atk: 26, def: 7, spd: 0.9 },
        Rogue: { hp: 260, atk: 28, def: 6, spd: 1.35 },
        Cleric: { hp: 300, atk: 18, def: 12, spd: 0.9 },
        Bard: { hp: 260, atk: 16, def: 10, spd: 1.0 },
        Paladin: { hp: 350, atk: 22, def: 14, spd: 0.85 },
        Necromancer: { hp: 230, atk: 22, def: 7, spd: 0.9 }
    };
    
    const stats = baseStats[role] || baseStats.Berserker;
    
    // Randomize slightly based on token ID
    const variance = (tokenId % 20) / 100; // 0-19% variance
    
    return {
        id: 10000 + tokenId, // High ID to avoid collision
        tokenId: tokenId,
        name: meta.name || `Chimera #${tokenId}`,
        hp: Math.floor(stats.hp * (1 + variance * 0.2)),
        atk: Math.floor(stats.atk * (1 + variance * 0.15)),
        def: Math.floor(stats.def * (1 + variance * 0.15)),
        spd: +(stats.spd * (1 + variance * 0.1)).toFixed(2),
        role: role,
        trait: body,
        isNFT: true,
        image: meta.image || null,
        metadata: meta
    };
}

function updateWalletUI() {
    const btn = document.getElementById('connect-wallet-btn');
    const status = document.getElementById('wallet-status');
    
    if (walletState.connected && walletState.address) {
        if (btn) btn.textContent = '‚úÖ Disconnect';
        if (status) {
            status.textContent = `${walletState.address.slice(0,6)}...${walletState.address.slice(-4)}`;
            status.classList.add('connected');
        }
    } else {
        if (btn) btn.textContent = 'üîó Connect';
        if (status) {
            status.textContent = '';
            status.classList.remove('connected');
        }
    }
}

// Disconnect (just clears state, doesn't revoke)
function disconnectWallet() {
    walletState = { connected: false, address: null, ownedTokens: [], nftFighters: [] };
    updateWalletUI();
    renderRoster();
}

// PFP cache to prevent flickering - keyed by fighter ID
const pfpCache = new Map();

// Battle name generator
const BATTLE_PREFIXES = ['Battle of', 'Siege of', 'Clash at', 'War for', 'Skirmish at', 'Assault on', 'Defense of', 'Raid on', 'Conquest of', 'Showdown at'];
const BATTLE_LOCATIONS = ['Skull Valley', 'Blood Ridge', 'Shadow Keep', 'Dragon\'s Maw', 'The Savage Pit', 'Bone Canyon', 'Thunder Peak', 'The Crimson Dunes', 'Venom Marsh', 'Iron Fortress', 'The Obsidian Gate', 'Howling Wastes', 'Demon\'s Crossing', 'The Ashen Fields', 'Razorback Pass'];

function generateBattleName() {
    const prefix = BATTLE_PREFIXES[Math.floor(Math.random() * BATTLE_PREFIXES.length)];
    const location = BATTLE_LOCATIONS[Math.floor(Math.random() * BATTLE_LOCATIONS.length)];
    return `‚öîÔ∏è ${prefix} ${location} ‚öîÔ∏è`;
}

// Store base stats for randomization
FIGHTERS.forEach(f => { f.baseHp = f.hp; f.baseAtk = f.atk; f.baseDef = f.def; f.baseSpd = f.spd; });

// === LAYERED PFP TRAIT SYSTEM ===
const TRAIT_POOLS = {
    creatures: ['Lizardman', 'Bearkin', 'Minotaur', 'Salamander', 'Frogfolk', 'Black_Ratman', 'Crocodillian', 'Raccoon', 'Possum', 'Brown_Ratman', 'White_Ratman', 'Winter_Bearkin', 'Poisonous_Frogfolk', 'Albino_Crocodillian', 'Gila_Monster', 'Radioactive_Lizard', 'Tree_Frogkin', 'Cosmic_Possum'],
    weapons: ['Steel_Longsword', 'Berserker_Axe', 'Crystal_Shard', 'Bone_Dagger', 'Rapier', 'Boar_Spear', 'Bone_Sword', 'Vampiric_Sword', 'Frost_Axe', 'Demonic_Blade', 'Gladius', 'Scimitar', 'Cutlass', 'Ebon_Longsword', 'Dragon_Fang'],
    boots: ["Rogue's_Boots", "Champion's_Boots", "Destroyer's_Boots", 'Tanking_Boots', "Healer's_Walkers", 'Mana_Imbued_Boots', "Jester's_Silk_Boots", 'Vampiric_Boots', 'Frostrime', 'Molten_Legs', 'Ebon_Boots'],
    chest: ['Tanking_Plate', 'Fury_Chestpiece', "Rogue's_Leather_Chest", "Jester's_Costume", 'Ebon_Chestplate', 'Molten_Chestplate', 'Vampiric_Chestpiece', 'Chainmail', 'Heavy_Marine', 'Dragon_Knights_Plate'],
    gloves: ['Tanking_Fists', 'Fury_Gloves', "Rogue's_Gloves", "Jester's_Silk_Gloves", 'Mana_Imbued_Gloves', "Healer's_Touch", "Necromancer's_Touch", 'Vampiric_Fists', 'Molten_Gloves', 'Ebon_Fists'],
    shoulders: ['Tanking_Plate', 'Fury_Shoulders', "Rogue's_Shoulderpads", "Jester's_Coif", 'Mana_Charged', "Healer's_Mantle", 'Vampiric_Shoulders', 'Molten_Shoulders', 'Ebon_Shoulders', 'Dragon_Knight_Mantle'],
    belt: ['Tanking_Plate', 'Fury_Belt', "Rogue_Stalker's_Wrap", "Jester's_Belt", "Healer's_Sash", "Necromancer's_Cinch", "Vampire's_Belt", 'Molten', 'Ebon_Belt'],
    shields: ['Steel_Buckler', 'Viking_Shield', "Hero's_Shield", 'Dragon_Scale_Shield', 'Frozen_Heart_Shield', 'Coffin_Shield', 'Bulwark_of_the_Titans'],
    capes: ["King's_Cloak", "Nightstalker's_Hood", 'Fine_Dark_Cape', "Wanderer's_Tattered_cloak", "Wizard's_Infinity_Cape"],
    robes: ["Summoner's_Robe", 'Apostle_of_Doom', "Blood_Lord", "Dark_Disciple", "Midnight's_Children"]
};

// Role-specific creature preferences
const ROLE_CREATURES = {
    'Tank': ['Bearkin', 'Winter_Bearkin', 'Minotaur', 'Crocodillian'],
    'Berserker': ['Minotaur', 'Bearkin', 'Lizardman', 'Gila_Monster'],
    'Mage': ['Salamander', 'Radioactive_Lizard', 'Frogfolk', 'Cosmic_Possum'],
    'Rogue': ['Black_Ratman', 'Brown_Ratman', 'Raccoon', 'Possum'],
    'Cleric': ['Albino_Crocodillian', 'Frogfolk', 'Tree_Frogkin', 'Lizardman'],
    'Necromancer': ['White_Ratman', 'Poisonous_Frogfolk', 'Salamander'],
    'Bard': ['Frogfolk', 'Tree_Frogkin', 'Raccoon', 'Possum']
};

// Generate random traits for a fighter
function generateFighterTraits(fighter, rng) {
    const pick = (arr) => arr[Math.floor(rng.n() * arr.length)];
    
    // Creature based on role
    const roleCreatures = ROLE_CREATURES[fighter.role] || TRAIT_POOLS.creatures;
    fighter.creature = pick(roleCreatures);
    
    // Gear varies by role
    fighter.weapon = pick(TRAIT_POOLS.weapons);
    fighter.boots = pick(TRAIT_POOLS.boots);
    fighter.gloves = pick(TRAIT_POOLS.gloves);
    fighter.belt = pick(TRAIT_POOLS.belt);
    fighter.shoulders = pick(TRAIT_POOLS.shoulders);
    
    // Role-specific gear
    if (fighter.role === 'Tank') {
        fighter.chest = pick(['Tanking_Plate', 'Heavy_Marine', 'Dragon_Knights_Plate', 'Chainmail']);
        fighter.shield = pick(TRAIT_POOLS.shields);
    } else if (fighter.role === 'Mage' || fighter.role === 'Necromancer' || fighter.role === 'Cleric') {
        fighter.robe = pick(TRAIT_POOLS.robes);
    } else {
        fighter.chest = pick(TRAIT_POOLS.chest);
    }
    
    // Rare cape (20% chance)
    if (rng.n() < 0.2) {
        fighter.cape = pick(TRAIT_POOLS.capes);
    }
    
    return fighter;
}

// Generate PFP for roster display (async) - uses pfpCache defined above
async function generateRosterPFP(fighter) {
    if (pfpCache.has(fighter.id)) return pfpCache.get(fighter.id);
    
    if (typeof PFPGenerator !== 'undefined') {
        try {
            const traits = {
                creature: fighter.creature,
                weapon: fighter.weapon,
                boots: fighter.boots,
                chest: fighter.chest,
                gloves: fighter.gloves,
                shoulders: fighter.shoulders,
                belt: fighter.belt,
                shield: fighter.shield,
                cape: fighter.cape,
                robe: fighter.robe
            };
            const dataUrl = await PFPGenerator.generatePFP(traits, { size: 64 });
            pfpCache.set(fighter.id, dataUrl);
            return dataUrl;
        } catch (e) {
            console.warn('PFP gen failed for', fighter.name, e);
        }
    }
    return null;
}

// Apply generated PFPs to roster cards after render
async function applyRosterPFPs() {
    for (const f of FIGHTERS) {
        const pfpUrl = await generateRosterPFP(f);
        if (pfpUrl) {
            const card = document.getElementById(`c${f.id}`);
            if (card) {
                const img = card.querySelector('.roster-img img');
                if (img) img.src = pfpUrl;
            }
        }
    }
}

// RNG
class RNG { constructor(s){this.s=this.h(String(s))} h(s){let h=0;for(let i=0;i<s.length;i++)h=((h<<5)-h)+s.charCodeAt(i)&0x7fffffff;return h||1} n(){this.s=(this.s*1103515245+12345)&0x7fffffff;return this.s/0x7fffffff} i(a,b){return Math.floor(this.n()*(b-a+1))+a} sh(a){const r=[...a];for(let i=r.length-1;i>0;i--){const j=Math.floor(this.n()*(i+1));[r[i],r[j]]=[r[j],r[i]]}return r} }

// Random walls generated each battle - solid, impassable
const WALLS = []; // Generated per-battle
const PILLARS = []; // Not used

function show(id) { document.querySelectorAll('.screen').forEach(s=>s.classList.add('hidden')); document.getElementById(id).classList.remove('hidden'); }
function showFAQ() { document.getElementById('faq-modal').style.display = 'block'; }
function hideFAQ() { document.getElementById('faq-modal').style.display = 'none'; }

// Zoom control for battle arena
let currentZoom = 1;
function setZoom(level) {
    currentZoom = level;
    const arena = document.getElementById('arena');
    if (!arena) return;
    
    // Remove all zoom classes
    arena.classList.remove('zoom-1x', 'zoom-1-5x', 'zoom-2x', 'zoom-3x');
    
    // Apply new zoom
    if (level === 1) arena.classList.add('zoom-1x');
    else if (level === 1.5) arena.classList.add('zoom-1-5x');
    else if (level === 2) arena.classList.add('zoom-2x');
    else if (level === 3) arena.classList.add('zoom-3x');
    
    // Update button states
    document.querySelectorAll('.zoom-btn').forEach(btn => {
        btn.classList.toggle('active', parseFloat(btn.dataset.zoom) === level);
    });
    
    console.log(`üîç Zoom: ${level}x`);
}

function goSelect() { state.king=null; state.general=null; state.captains=[]; state.army=[]; document.getElementById('result').classList.remove('active'); show('select-screen'); renderRoster(); updateSelect(); }

// Shuffle roster with random stats variation
function shuffleRoster() {
    // Shuffle the order
    FIGHTERS.sort(() => Math.random() - 0.5);
    
    // RNG for trait generation
    const traitRng = new RNG(Date.now());
    
    // Clear PFP cache for fresh generation
    pfpCache.clear();
    
    // Re-assign IDs to shuffled order (for display consistency)
    FIGHTERS.forEach((f, i) => {
        f.displayId = i + 1;
        // Randomize stats within ¬±15% of base
        f.hp = Math.floor(f.baseHp * (0.85 + Math.random() * 0.3));
        f.atk = Math.floor(f.baseAtk * (0.85 + Math.random() * 0.3));
        f.def = Math.floor(f.baseDef * (0.85 + Math.random() * 0.3));
        f.spd = +(f.baseSpd * (0.9 + Math.random() * 0.2)).toFixed(2);
        
        // Generate layered PFP traits
        generateFighterTraits(f, traitRng);
    });
    
    // Reset selection
    state.king = null;
    state.army = [];
    renderRoster();
    updateSelect();
    console.log('üé≤ Roster shuffled! Stats + traits randomized.');
}

// Load roster from JSON (for future NFT integration)
async function loadRosterFromJSON() {
    try {
        const res = await fetch('fighters.json');
        const data = await res.json();
        if (data.fighters && data.fighters.length > 0) {
            FIGHTERS = data.fighters;
            FIGHTERS.forEach(f => { f.baseHp = f.hp; f.baseAtk = f.atk; f.baseDef = f.def; f.baseSpd = f.spd; });
            shuffleRoster();
            console.log(`‚úÖ Loaded ${FIGHTERS.length} fighters from JSON`);
        }
    } catch (e) {
        console.log('Using embedded roster (JSON not found)');
    }
}

function renderRoster() {
    // Regular fighters
    document.getElementById('roster').innerHTML = FIGHTERS.map(f=>`
        <div class="roster-card" id="c${f.id}" onclick="pick(${f.id})">
            <div class="roster-img"><img src="${getSpriteUrl(f)}" style="image-rendering:pixelated" data-fighter-id="${f.id}"></div>
            <div class="roster-name">${f.name}</div>
            <div class="roster-role">${f.role}</div>
            <div class="roster-stats">‚öî${f.atk} üõ°${f.def} ‚ù§${f.hp}</div>
        </div>
    `).join('');
    
    // Apply layered PFPs (async - updates images as they generate)
    applyRosterPFPs();
    
    // Render NFT fighters if connected
    const nftSection = document.getElementById('nft-section');
    const nftRoster = document.getElementById('nft-roster');
    
    if (walletState.connected && walletState.nftFighters.length > 0) {
        nftSection.style.display = 'block';
        nftRoster.innerHTML = walletState.nftFighters.filter(f => f).map(f => `
            <div class="roster-card" id="c${f.id}" onclick="pickNFT(${f.tokenId})" style="border-color:#4169E1;background:rgba(65,105,225,0.1);">
                <div class="roster-img" style="position:relative;">
                    ${f.image ? `<img src="${f.image.replace('ipfs://', 'https://ipfs.io/ipfs/')}" style="width:100%;height:100%;object-fit:cover;">` : `<img src="${getSpriteUrl(f)}" style="image-rendering:pixelated">`}
                    <div style="position:absolute;bottom:2px;right:2px;background:#4169E1;color:#fff;font-size:7px;padding:2px 4px;border-radius:3px;">#${f.tokenId}</div>
                </div>
                <div class="roster-name" style="color:#4169E1;">${f.name}</div>
                <div class="roster-role">${f.role}</div>
                <div class="roster-stats">‚öî${f.atk} üõ°${f.def} ‚ù§${f.hp}</div>
            </div>
        `).join('');
    } else {
        nftSection.style.display = 'none';
    }
}

// Pick an NFT fighter (add to FIGHTERS array temporarily)
function pickNFT(tokenId) {
    const nft = walletState.nftFighters.find(f => f && f.tokenId === tokenId);
    if (!nft) return;
    
    // Check if already added
    if (FIGHTERS.find(f => f.id === nft.id)) {
        // Already in roster, just pick it
        pick(nft.id);
        return;
    }
    
    // Add to FIGHTERS array
    FIGHTERS.push({...nft, baseHp: nft.hp, baseAtk: nft.atk, baseDef: nft.def, baseSpd: nft.spd});
    
    // Re-render and select
    renderRoster();
    pick(nft.id);
}

function pick(id) {
    // Selection order: King -> General -> 3 Captains -> 10 Army
    const allSelected = [state.king, state.general, ...state.captains, ...state.army].filter(Boolean);
    
    if (allSelected.includes(id)) {
        // Deselect - remove from wherever it is
        if (state.king === id) state.king = null;
        else if (state.general === id) state.general = null;
        else if (state.captains.includes(id)) state.captains = state.captains.filter(x=>x!==id);
        else state.army = state.army.filter(x=>x!==id);
    } else {
        // Select in order: King -> General -> Captains -> Army
        if (!state.king) state.king = id;
        else if (!state.general) state.general = id;
        else if (state.captains.length < 3) state.captains.push(id);
        else if (state.army.length < 10) state.army.push(id); // 10 regular fighters
    }
    updateSelect();
}

function updateSelect() {
    document.querySelectorAll('.roster-card').forEach(c=>c.classList.remove('selected','king','general','captain'));
    if (state.king) document.getElementById(`c${state.king}`)?.classList.add('king');
    if (state.general) document.getElementById(`c${state.general}`)?.classList.add('general');
    state.captains.forEach(id=>document.getElementById(`c${id}`)?.classList.add('captain'));
    state.army.forEach(id=>document.getElementById(`c${id}`)?.classList.add('selected'));
    
    const ki = document.getElementById('king-img');
    const kinf = document.getElementById('king-info');
    if (state.king) {
        const k = FIGHTERS.find(f=>f.id===state.king);
        if (k) {
            const imgSrc = k.isNFT && k.image ? k.image.replace('ipfs://', 'https://ipfs.io/ipfs/') : getSpriteUrl(k);
            ki.innerHTML = `<img src="${imgSrc}" style="${k.isNFT ? '' : 'image-rendering:pixelated'}">`;
            kinf.innerHTML = `<b>${k.name}</b><br>${k.role}${k.isNFT ? '<br><span style="color:#4169E1;font-size:9px;">üé® NFT #' + k.tokenId + '</span>' : ''}`;
        }
    } else {
        ki.innerHTML = '';
        kinf.innerHTML = 'Select King';
    }
    
    // Show command structure progress
    const total = (state.king?1:0) + (state.general?1:0) + state.captains.length + state.army.length;
    let statusText = '';
    if (!state.king) statusText = 'üëë Pick KING';
    else if (!state.general) statusText = '‚≠ê Pick GENERAL';
    else if (state.captains.length < 3) statusText = `üéñÔ∏è Pick CAPTAINS (${state.captains.length}/3)`;
    else statusText = `‚öîÔ∏è Army: ${state.army.length}/10`;
    
    document.getElementById('army-count').textContent = statusText;
    const btn = document.getElementById('start-btn');
    const ready = state.king && state.general && state.captains.length === 3 && state.army.length === 10;
    btn.disabled = !ready;
    btn.textContent = ready ? '‚öîÔ∏è TO BATTLE!' : `${total}/15 SELECTED`;
}

function randomFill() {
    // Randomize fighter stats first
    FIGHTERS.forEach(f => {
        f.hp = f.baseHp + Math.floor((Math.random() - 0.5) * 60);
        f.atk = f.baseAtk + Math.floor((Math.random() - 0.5) * 8);
        f.def = f.baseDef + Math.floor((Math.random() - 0.5) * 6);
        f.spd = f.baseSpd + (Math.random() - 0.5) * 0.3;
    });
    
    // Clear current selection
    state.king = null;
    state.general = null;
    state.captains = [];
    state.army = [];
    
    // Shuffle and pick random fighters: 1 King + 1 General + 3 Captains + 10 Army
    const shuffled = [...FIGHTERS].sort(() => Math.random() - 0.5);
    state.king = shuffled[0].id;
    state.general = shuffled[1].id;
    state.captains = shuffled.slice(2, 5).map(f => f.id);
    state.army = shuffled.slice(5, 15).map(f => f.id);
    
    renderRoster();
    updateSelect();
}

function quickStart() {
    randomFill();
    setTimeout(() => startBattle(), 100);
}

function startBattle() {
    if (!state.king || !state.general || state.captains.length !== 3 || state.army.length !== 10) return; // Command structure: King + General + 3 Captains + 10 Army
    state.paused = false;
    state.inspected = null;
    document.getElementById('result').classList.remove('active');
    show('arena-screen');
    
    // Generate epic battle name
    document.getElementById('battle-title').textContent = generateBattleName();
    
    const rng = new RNG(Date.now());
    const arena = document.getElementById('arena');
    arena.innerHTML = '';
    fighterCache.clear(); // Clear cached fighter refs for new battle
    arenaEl = arena; // Update cached arena ref
    // Cache arena dimensions for transform positioning (defer to ensure layout complete)
    requestAnimationFrame(() => {
        const rect = arena.getBoundingClientRect();
        arenaRect.width = rect.width;
        arenaRect.height = rect.height;
    });
    
    // Click empty space to close inspector
    arena.onclick = (e) => {
        if (e.target === arena || e.target.classList.contains('wall')) {
            closeInspector();
        }
    };
    
    // RANDOM WALLS - generate 2-4 solid barriers each battle
    const numWalls = 2 + Math.floor(rng.n() * 3); // 2-4 walls
    const battleWalls = [];
    for (let i = 0; i < numWalls; i++) {
        const isVertical = rng.n() > 0.5;
        const wall = {
            id: `wall-${i}`,
            x: 0.25 + rng.n() * 0.5, // Keep walls in middle 50% horizontally
            y: 0.15 + rng.n() * 0.7, // Keep walls away from spawn edges
            w: isVertical ? 0.02 : (0.08 + rng.n() * 0.12), // Width
            h: isVertical ? (0.08 + rng.n() * 0.15) : 0.02   // Height
        };
        // Don't place walls too close to center or each other
        const tooClose = battleWalls.some(w => Math.hypot(w.x - wall.x, w.y - wall.y) < 0.15);
        const tooCenter = Math.abs(wall.x - 0.5) < 0.1 && Math.abs(wall.y - 0.5) < 0.1;
        if (!tooClose && !tooCenter) {
            battleWalls.push(wall);
        }
    }
    
    // Draw walls
    battleWalls.forEach(w => {
        const el = document.createElement('div');
        el.id = w.id;
        el.className = 'wall';
        el.style.cssText = `left:${(w.x-w.w/2)*100}%;top:${(w.y-w.h/2)*100}%;width:${w.w*100}%;height:${w.h*100}%;`;
        arena.appendChild(el);
    });
    
    // Personalities affect combat behavior
    const PERSONALITIES = ['Reckless', 'Cautious', 'Aggressive', 'Defensive', 'Tactical', 'Berserker'];
    
    // Create fighters - officers get rank bonuses (Captain/General/King)
    const mk = (f, team, isKing, x, y, rank = null) => {
        // Apply buffs if fighter has ANY rank (King, General, or Captain)
        const hpMult = rank ? rank.hpMult : 1;
        const atkMult = rank ? rank.atkMult : 1;
        const defMult = rank ? rank.defMult : 1;
        return {
            ...f, uid: `${team}-${f.id}-${rng.n().toString(36).slice(2,5)}`,
            gear: GEAR[f.role] || GEAR.Tank,
            hp: Math.floor(f.hp * hpMult), maxHp: Math.floor(f.hp * hpMult),
            atk: Math.floor(f.atk * atkMult), def: Math.floor(f.def * defMult),
            alive: true, team, king: isKing, x, y, kills: 0, dmgDone: 0, dmgTaken: 0, healDone: 0,
            rank: rank ? rank.rank : null,
            rankIcon: rank ? rank.icon : null,
            buffs: [],
            buffCd: 0,
            personality: PERSONALITIES[Math.floor(rng.n() * PERSONALITIES.length)],
            shieldDir: team === 0 ? 0 : Math.PI,
            aiState: 'Idle',
            idleTime: 0,
            healCd: 0,
            buffCdSelf: 0,
            spellCd: 0,
            specialCd: 0,
            atkCd: 0,
            rallyCd: 0,
            chargeCd: 0, // Gap closer cooldown for melee
            mana: f.role === 'Mage' ? 100 : (f.role === 'Cleric' ? 80 : (f.role === 'Bard' ? 90 : (f.role === 'Necromancer' ? 100 : (f.role === 'Paladin' ? 60 : 0)))),
            maxMana: f.role === 'Mage' ? 100 : (f.role === 'Cleric' ? 80 : (f.role === 'Bard' ? 90 : (f.role === 'Necromancer' ? 100 : (f.role === 'Paladin' ? 60 : 0)))),
            summons: 0,
            raiseCd: 0,
            raisesCount: 0  // Max 2 resurrections per necromancer per match
        };
    };
    
    // Get player's command structure
    const pKing = FIGHTERS.find(f=>f.id===state.king);
    const pGeneral = FIGHTERS.find(f=>f.id===state.general);
    const pCaptains = state.captains.map(id=>FIGHTERS.find(f=>f.id===id));
    const pArmy = state.army.map(id=>FIGHTERS.find(f=>f.id===id));
    const used = new Set([state.king, state.general, ...state.captains, ...state.army]);
    
    let avail = FIGHTERS.filter(f=>!used.has(f.id));
    while (avail.length < 15) avail.push({...FIGHTERS[rng.i(0,FIGHTERS.length-1)], id:100+avail.length});
    avail = rng.sh(avail);
    
    // 15v15 BATTLE - 2 TEAMS
    const t0 = [], t1 = [];
    
    // TEAM NAME GENERATOR - lore-appropriate names
    const TEAM_PREFIXES = ['The', 'Clan', 'House', 'Legion', 'Band of', 'Order of', 'The Savage', 'The Iron', 'The Blood', 'The Shadow'];
    const TEAM_NOUNS = ['Chimeras', 'Reapers', 'Wolves', 'Dragons', 'Vipers', 'Ravens', 'Titans', 'Berserkers', 'Wardens', 'Slayers', 'Marauders', 'Sentinels', 'Hellions', 'Outcasts', 'Furies'];
    const generateTeamName = () => {
        const prefix = TEAM_PREFIXES[Math.floor(rng.n() * TEAM_PREFIXES.length)];
        const noun = TEAM_NOUNS[Math.floor(rng.n() * TEAM_NOUNS.length)];
        return `${prefix} ${noun}`;
    };
    const playerTeamName = generateTeamName();
    const enemyTeamName = generateTeamName();
    
    // Tactical formation - tanks front, ranged back, king protected
    const sortByRole = arr => {
        const order = {Tank:0, Berserker:1, Rogue:2, Mage:3, Cleric:4};
        return [...arr].sort((a,b)=>(order[a.role]||2)-(order[b.role]||2));
    };
    
    // RANK DEFINITIONS - buff multipliers
    const RANKS = {
        King: { rank: 'King', hpMult: 1.75, atkMult: 1.2, defMult: 1.2, icon: 'üëë' },
        General: { rank: 'General', hpMult: 1.4, atkMult: 1.1, defMult: 1.1, icon: '‚≠ê' },
        Captain: { rank: 'Captain', hpMult: 1.25, atkMult: 1.05, defMult: 1.05, icon: 'üéñÔ∏è' }
    };
    
    // Enemy leader rank (random)
    const getLeaderRank = () => {
        const roll = rng.n();
        if (roll < 0.10) return RANKS.King;
        if (roll < 0.35) return RANKS.General;
        return RANKS.Captain;
    };
    const enemyRank = getLeaderRank();
    
    // Team 0 (left side) - player's command structure
    // Only King gets isLeader=true, others get rank via the rank parameter
    t0.push(mk(pKing, 0, true, 0.08, 0.5, RANKS.King));
    t0.push(mk(pGeneral, 0, false, 0.13, 0.35, RANKS.General));
    pCaptains.forEach((f, i) => {
        const y = 0.2 + i * 0.3;
        t0.push(mk(f, 0, false, 0.18, y, RANKS.Captain));
    });
    const sorted0 = sortByRole(pArmy);
    sorted0.forEach((f, i) => {
        const row = Math.floor(i / 5);
        const col = i % 5;
        const x = 0.22 + row * 0.05;
        const y = 0.12 + col * 0.19;
        t0.push(mk(f, 0, false, x, y));
    });
    
    // Team 1 (right side) - enemy with similar structure
    const eKing = avail[0];
    const eGeneral = avail[1];
    const eCaptains = avail.slice(2, 5);
    const eArmy = sortByRole(avail.slice(5, 15));
    
    t1.push(mk(eKing, 1, true, 0.92, 0.5, enemyRank));
    t1.push(mk(eGeneral, 1, false, 0.87, 0.35, rng.n() < 0.3 ? RANKS.General : RANKS.Captain));
    eCaptains.forEach((f, i) => {
        const y = 0.2 + i * 0.3;
        t1.push(mk(f, 1, false, 0.82, y, RANKS.Captain));
    });
    eArmy.forEach((f, i) => {
        const row = Math.floor(i / 5);
        const col = i % 5;
        const x = 0.78 - row * 0.05;
        const y = 0.12 + col * 0.19;
        t1.push(mk(f, 1, false, x, y));
    });
    
    // Log the command structures
    log(`üëë ${playerTeamName}: King ${pKing.name}`, 'king');
    log(`‚≠ê General ${pGeneral.name} leads your vanguard`, 'buff');
    log(`üéñÔ∏è ${pCaptains.length} Captains rally your troops`, 'buff');
    log(`${enemyRank.icon} ${enemyTeamName}: ${enemyRank.rank} ${eKing.name}`, enemyRank.rank === 'King' ? 'king' : 'buff');
    
    state.match = { 
        rng, 
        teams: [{f:t0, morale:100, kingAlive:true, name: playerTeamName}, {f:t1, morale:100, kingAlive:true, name: enemyTeamName}],
        teamNames: [playerTeamName, enemyTeamName],
        status:'live', 
        winner:null, 
        tick:0, 
        walls: battleWalls, 
        items: [], 
        itemSpawnCd: 0 
    };
    
    // ITEM DEFINITIONS
    const ITEM_TYPES = [
        { type: 'health', icon: 'üß™', name: 'Health Potion', effect: (f) => { f.hp = Math.min(f.maxHp, f.hp + 50); return '+50 HP'; } },
        { type: 'attack', icon: '‚öîÔ∏è', name: 'Battle Axe', effect: (f) => { f.atk += 8; return '+8 ATK'; } },
        { type: 'defense', icon: 'üõ°Ô∏è', name: 'Shield', effect: (f) => { f.def += 6; return '+6 DEF'; } },
        { type: 'speed', icon: 'üí®', name: 'Swift Boots', effect: (f) => { f.spd += 0.3; return '+SPD'; } },
        { type: 'gold', icon: 'üí∞', name: 'Gold Coin', effect: (f) => { f.kills += 1; return '+1 KILL'; } },  // Bonus kill credit
        { type: 'spell', icon: 'üìú', name: 'Spell Scroll', effect: (f) => { f.mana = Math.min(f.maxMana || 100, (f.mana || 0) + 50); return '+50 MANA'; } },
        { type: 'chest', icon: 'üéÅ', name: 'Treasure Chest', effect: (f) => { 
            // Random buff
            const buffs = [
                () => { f.hp = Math.min(f.maxHp, f.hp + 30); return '+30 HP'; },
                () => { f.atk += 5; return '+5 ATK'; },
                () => { f.def += 4; return '+4 DEF'; },
                () => { f.spd += 0.2; return '+SPD'; },
                () => { f.buffs.push({name:'Lucky', icon:'üçÄ', duration:20, atkBonus:3, defBonus:3}); return 'üçÄ LUCKY'; }
            ];
            return buffs[Math.floor(Math.random() * buffs.length)]();
        }},
    ];
    state.match.itemTypes = ITEM_TYPES;
    state.match.battleLog = []; // Store key events for story generation
    
    // ==========================================
    // BATTLE TITLE GENERATOR
    // ==========================================
    function generateBattleTitle(team0, team1) {
        const all = [...team0, ...team1];
        const roles0 = team0.map(f => f.role);
        const roles1 = team1.map(f => f.role);
        
        // Count special unit types
        const necros = all.filter(f => f.role === 'Necromancer').length;
        const rogues = all.filter(f => f.role === 'Rogue').length;
        const mages = all.filter(f => f.role === 'Mage').length;
        const clerics = all.filter(f => f.role === 'Cleric').length;
        const berserkers = all.filter(f => f.role === 'Berserker').length;
        const bards = all.filter(f => f.role === 'Bard').length;
        const tanks = all.filter(f => f.role === 'Tank').length;
        
        // Check for king ranks
        const hasLegendaryKing = all.some(f => f.king && f.rank === 'King');
        const hasGenerals = all.filter(f => f.king && f.rank === 'General').length;
        
        // Generate epic title based on composition
        const prefixes = ['The Battle of', 'The Siege of', 'The War of', 'The Clash at', 'The Stand at', 'The Fall of', 'The Rise of'];
        const prefix = prefixes[Math.floor(rng.n() * prefixes.length)];
        
        let theme = '';
        
        // Priority themes based on unique compositions
        if (necros >= 2) {
            theme = ['the Lich Kings', 'the Undying', 'Dread Summit', 'the Bone Throne', 'Necrotic Fields'][Math.floor(rng.n() * 5)];
        } else if (rogues >= 4) {
            theme = ['Shadow Valley', 'the Hidden Blades', 'Whisper Hollow', 'the Assassin\'s Mark'][Math.floor(rng.n() * 4)];
        } else if (mages >= 4) {
            theme = ['the Arcane Spire', 'Stormfire Peak', 'the Mage Wars', 'Elemental Fury'][Math.floor(rng.n() * 4)];
        } else if (berserkers >= 4) {
            theme = ['Blood Ridge', 'the Berserker Horde', 'Crimson Fields', 'Rage Mountain'][Math.floor(rng.n() * 4)];
        } else if (clerics >= 3) {
            theme = ['the Holy Ground', 'Divine Crossing', 'the Sacred Stand', 'Light\'s End'][Math.floor(rng.n() * 4)];
        } else if (bards >= 2) {
            theme = ['the Battle Hymn', 'Song\'s End', 'the War Drums', 'Echo Valley'][Math.floor(rng.n() * 4)];
        } else if (tanks >= 5) {
            theme = ['the Iron Wall', 'Shield Mountain', 'the Unbreakable', 'Steel Gate'][Math.floor(rng.n() * 4)];
        } else if (hasLegendaryKing) {
            theme = ['the Crown', 'the Throne', 'Royal Blood', 'the King\'s Last Stand', 'Sovereign\'s Fall'][Math.floor(rng.n() * 5)];
        } else {
            // Generic epic names - expanded pool for variety
            const genericThemes = [
                'Savage Lands', 'the Crimson Dawn', 'Ashenvale', 'Thundering Plains', 'the Broken Alliance', 
                'Dragon\'s Reach', 'the Final Hour', 'Dusk Hollow', 'the Savage Pit', 'Whispering Graves',
                'Bloodfen Marshes', 'Stormpeak', 'the Ashen Vale', 'Oak Ridge', 'the Frozen Throne',
                'Blackstone Keep', 'the Sundered Realm', 'Dreadmire', 'the Scarlet Fields', 'Ironhold',
                'the Wailing Chasm', 'Ember\'s End', 'the Shattered Plains', 'Wraithwood', 'Valor\'s Edge',
                'the Bleeding Sands', 'Nightfall Hollow', 'the Burning Steppes', 'Grimwatch', 'Soulfire Peak'
            ];
            theme = genericThemes[Math.floor(rng.n() * genericThemes.length)];
        }
        
        // Ensure uniqueness by varying if duplicate
        let attempt = 0;
        let name = `${prefix} ${theme}`;
        while (usedBattleNames.includes(name) && attempt < 50) {
            // Vary by cycling prefixes and adding modifiers
            const modifiers = ['', 'First', 'Second', 'Third', 'Great', 'Last', 'Final', 'Bloody', 'Fateful'];
            const mod = modifiers[Math.floor(rng.n() * modifiers.length)];
            const newPrefix = prefixes[Math.floor(rng.n() * prefixes.length)];
            name = mod ? `The ${mod} ${newPrefix.replace('The ', '')} ${theme}` : `${newPrefix} ${theme}`;
            attempt++;
        }
        usedBattleNames.push(name);
        return name;
    }
    
    // Create teams array for easier access
    const teams = [t0, t1];
    
    // Generate title from all fighters
    const allFightersFlat = teams.flat();
    const battleTitle = generateBattleTitle(allFightersFlat.slice(0, 10), allFightersFlat.slice(10));
    state.match.battleTitle = battleTitle;
    
    // Display battle title in header
    const headerEl = document.querySelector('.score-bar') || document.querySelector('.arena-header');
    if (headerEl) {
        let titleEl = document.getElementById('battle-title');
        if (!titleEl) {
            titleEl = document.createElement('div');
            titleEl.id = 'battle-title';
            titleEl.style.cssText = 'text-align:center;font-family:"Press Start 2P",monospace;font-size:12px;color:#FFD700;text-shadow:0 0 10px rgba(255,215,0,0.5);padding:8px;margin-bottom:5px;';
            headerEl.prepend(titleEl);
        }
        titleEl.textContent = `‚öîÔ∏è ${battleTitle} ‚öîÔ∏è`;
    }
    
    log(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`, 'king');
    log(`‚öîÔ∏è ${battleTitle} ‚öîÔ∏è`, 'king');
    log(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`, 'king');
    
    // ROGUE STEALTH - initialize tracking (rogues can stealth when out of combat)
    teams.flat().forEach(f => {
        f.lastCombatTick = -10; // Start as "out of combat"
        f.stealthCooldown = 0;
        if (f.role === 'Rogue') {
            f.invisible = false;
            f.invisTicks = 0;
        }
    });
    
    // SQUAD SYSTEM - split into tactical groups (simplified for 5-man teams)
    // Vanguard: Push forward, engage enemy
    // Guard: Protect king, hold position  
    // Flankers: Circle around, hit backline
    teams.forEach(team => {
        const nonKing = team.filter(f => !f.king);
        // Assign by role preferences
        const tanks = nonKing.filter(f => f.role === 'Tank');
        const berserkers = nonKing.filter(f => f.role === 'Berserker');
        const rogues = nonKing.filter(f => f.role === 'Rogue');
        const mages = nonKing.filter(f => f.role === 'Mage');
        const clerics = nonKing.filter(f => f.role === 'Cleric');
        const bards = nonKing.filter(f => f.role === 'Bard');
        const necros = nonKing.filter(f => f.role === 'Necromancer');
        const others = nonKing.filter(f => !['Tank','Berserker','Rogue','Mage','Cleric','Bard','Necromancer'].includes(f.role));
        
        // Vanguard: Tanks + Berserkers lead the charge
        const vanguard = [...tanks, ...berserkers, ...others].slice(0, 5);
        // Flankers: Rogues + fast fighters
        const flankers = [...rogues, ...berserkers.slice(tanks.length > 2 ? 0 : 1)].slice(0, 5);
        // Guard: Everyone else protects king (clerics, mages, bards, necros)
        const guard = [...clerics, ...mages, ...bards, ...necros, ...tanks.slice(2)];
        
        // Fill squads to ~5 each if unbalanced
        const assigned = new Set([...vanguard, ...flankers]);
        const remaining = nonKing.filter(f => !assigned.has(f));
        
        vanguard.forEach(f => f.squad = 'vanguard');
        flankers.forEach(f => f.squad = 'flanker');
        guard.forEach(f => f.squad = 'guard');
        remaining.forEach((f, i) => f.squad = i % 3 === 0 ? 'vanguard' : i % 3 === 1 ? 'flanker' : 'guard');
        
        // King is always guarded
        const king = team.find(f => f.king);
        if (king) king.squad = 'guard';
    });
    
    document.getElementById('log-content').innerHTML = '';
    log('Battle begins!', 'king');
    
    // Announce squad formations (your team = teams[0])
    const yourTeam = teams[0];
    const yourVanguard = yourTeam.filter(f => f.squad === 'vanguard').length;
    const yourFlankers = yourTeam.filter(f => f.squad === 'flanker').length;
    const yourGuard = yourTeam.filter(f => f.squad === 'guard').length;
    log(`‚öîÔ∏è Your squad forms up: ${yourVanguard} vanguard, ${yourFlankers} flankers, ${yourGuard} guard`, 'buff');
    
    // Announce rogues (all teams)
    const rogueCount = teams.flat().filter(f => f.role === 'Rogue').length;
    if (rogueCount > 0) {
        log(`üó°Ô∏è ${rogueCount} rogues circle the battlefield, seeking openings...`, 'buff');
    }
    
    lastTick = performance.now();
    requestAnimationFrame(loop);
}

let lastTick = 0;
let lastRender = 0;
const TICK_MS = 750; // Slower tick for performance + dramatic pacing
const RENDER_MS = 33; // Cap render at ~30fps to reduce flicker
function loop(ts) {
    if (!state.match || state.match.status !== 'live') return;
    if (state.paused) { requestAnimationFrame(loop); return; }
    
    if (ts - lastTick >= TICK_MS) {
        tick();
        lastTick = ts;
    }
    
    // Throttle rendering to reduce flicker
    if (ts - lastRender >= RENDER_MS) {
        render();
        lastRender = ts;
    }
    
    requestAnimationFrame(loop);
}

// Helper: Get all fighters across both teams
function getAllFighters(m) {
    return [...m.teams[0].f, ...m.teams[1].f];
}

function tick() {
    const m = state.match;
    m.tick++;
    const all = getAllFighters(m).filter(f=>f.alive);
    
    // Calculate battle state for each team (2-team)
    const t0Alive = m.teams[0].f.filter(f=>f.alive).length;
    const t1Alive = m.teams[1].f.filter(f=>f.alive).length;
    const t0Advantage = (t0Alive - t1Alive) / Math.max(t0Alive + t1Alive, 1);
    const t1Advantage = -t0Advantage;
    m.teams[0].advantage = t0Advantage;
    m.teams[1].advantage = t1Advantage;
    
    // ==========================================
    // ITEM SPAWNING - powerups appear in arena
    // ==========================================
    if (m.itemSpawnCd > 0) m.itemSpawnCd--;
    
    // Spawn items every 8-15 ticks, max 5 items at once
    if (m.itemSpawnCd <= 0 && m.items.length < 5) {
        m.itemSpawnCd = 8 + Math.floor(m.rng.n() * 8); // 8-15 ticks between spawns
        
        // Pick random item type
        const itemType = m.itemTypes[Math.floor(m.rng.n() * m.itemTypes.length)];
        
        // Find valid spawn position (not too close to walls or edges)
        let x, y, valid = false, attempts = 0;
        while (!valid && attempts < 20) {
            x = 0.15 + m.rng.n() * 0.7;  // Keep away from spawn edges
            y = 0.1 + m.rng.n() * 0.8;
            valid = true;
            // Check wall collision
            for (const w of m.walls) {
                if (x > w.x - w.w/2 - 0.03 && x < w.x + w.w/2 + 0.03 &&
                    y > w.y - w.h/2 - 0.03 && y < w.y + w.h/2 + 0.03) {
                    valid = false; break;
                }
            }
            attempts++;
        }
        
        if (valid) {
            const item = {
                id: `item-${m.tick}-${Math.random().toString(36).slice(2,6)}`,
                ...itemType,
                x, y,
                spawnTick: m.tick
            };
            m.items.push(item);
            log(`‚ú® ${item.icon} ${item.name} spawned!`, 'buff');
        }
    }
    
    // ==========================================
    // ITEM PICKUP - fighters grab nearby items
    // ==========================================
    m.items = m.items.filter(item => {
        // Check if any alive fighter is close enough to pick up
        for (const f of all) {
            const dist = Math.hypot(f.x - item.x, f.y - item.y);
            if (dist < 0.05) { // Pickup range
                // Apply effect
                const result = item.effect(f);
                showDmg(f.x, f.y, `${item.icon} ${result}`, 'buff');
                log(`${item.icon} ${fname(f)} picked up ${item.name}! ${result}`, 'buff');
                
                // Mark for removal with animation
                const el = document.getElementById(item.id);
                if (el) el.classList.add('picked');
                setTimeout(() => { const e = document.getElementById(item.id); if(e) e.remove(); }, 300);
                
                return false; // Remove from items array
            }
        }
        
        // Despawn after 30 ticks
        if (m.tick - item.spawnTick > 30) {
            const el = document.getElementById(item.id);
            if (el) el.remove();
            return false;
        }
        
        return true; // Keep item
    });
    
    // Find kings for rally aura
    const kings = all.filter(f => f.king);
    
    // ROUT MECHANIC - process fear/flee when king died recently
    m.teams.forEach((t, ti) => {
        if (!t.kingAlive && !t.routProcessed) {
            // King just died - apply rout debuff to remaining fighters
            t.routProcessed = true;
            t.routTicks = 30; // Rout lasts 30 ticks
            t.f.filter(f => f.alive && !f.king).forEach(f => {
                f.routed = true;
                f.routedTicks = 25 + Math.floor(m.rng.n() * 15); // 25-40 ticks of fear
                log(`üò± ${fname(f)} is ROUTED!`, 'rout');
            });
        }
        if (t.routTicks > 0) t.routTicks--;
    });
    
    // MERCY/SURRENDER MECHANIC - when king dead, few remain, low morale
    m.teams.forEach((t, ti) => {
        if (!t.kingAlive && !t.surrendered) {
            const alive = t.f.filter(f => f.alive && !f.king);
            const enemyAlive = m.teams[1-ti].f.filter(f => f.alive).length;
            
            // Conditions: King dead, ‚â§3 fighters left, morale <30, outnumbered 2:1
            if (alive.length <= 3 && alive.length > 0 && t.morale < 30 && enemyAlive >= alive.length * 2) {
                // Check if they ask for mercy (random chance, increases with desperation)
                const surrenderChance = (30 - t.morale) / 100 + (1 - alive.length / 5) * 0.3;
                if (m.rng.n() < surrenderChance) {
                    t.surrendered = true;
                    
                    // All remaining fighters switch sides!
                    alive.forEach(f => {
                        f.team = 1 - ti; // Switch to enemy team
                        f.routed = false;
                        f.routedTicks = 0;
                        f.aiState = 'Surrendered';
                        f.name = `‚öîÔ∏è ${f.name.replace(/^üßü |^‚öîÔ∏è /, '')}`; // Mark as turncoat
                        // Move them to the other team's array
                        t.f = t.f.filter(x => x !== f);
                        m.teams[1-ti].f.push(f);
                        showDmg(f.x, f.y, 'üôè MERCY!', 'buff');
                    });
                    
                    log(`üôè The remaining ${alive.length} fighters beg for mercy and JOIN THE ENEMY!`, 'king');
                    screenShake('small');
                }
            }
        }
    });
    
    // Calculate team centroid for grouping
    const teamCentroid = [0, 1].map(ti => {
        const tf = m.teams[ti].f.filter(f => f.alive);
        if (!tf.length) return {x: 0.5, y: 0.5};
        return {
            x: tf.reduce((s, f) => s + f.x, 0) / tf.length,
            y: tf.reduce((s, f) => s + f.y, 0) / tf.length
        };
    });
    
    all.forEach(f => {
        // 2-team battle: enemies = the other team
        const enemies = m.teams[1-f.team].f.filter(e=>e.alive && !e.invisible);
        const allies = m.teams[f.team].f.filter(a=>a.alive && a.uid !== f.uid);
        if (!enemies.length) return;
        
        // UNSTUCK LOGIC - detect and fix stuck fighters
        if (!f.lastPos) f.lastPos = {x: f.x, y: f.y, tick: 0};
        const movedDist = Math.hypot(f.x - f.lastPos.x, f.y - f.lastPos.y);
        if (movedDist < 0.005) { // Barely moved
            f.stuckTicks = (f.stuckTicks || 0) + 1;
            if (f.stuckTicks > 8) { // Stuck for 8+ ticks
                // JITTER - random offset to break free
                const jitterX = (m.rng.n() - 0.5) * 0.08;
                const jitterY = (m.rng.n() - 0.5) * 0.08;
                f.x = Math.max(0.05, Math.min(0.95, f.x + jitterX));
                f.y = Math.max(0.08, Math.min(0.92, f.y + jitterY));
                f.aiState = 'Unsticking';
                f.stuckTicks = 0;
            }
        } else {
            f.stuckTicks = 0;
        }
        f.lastPos = {x: f.x, y: f.y};
        
        // ROUT CHECK - routed fighters scatter in panic!
        if (f.routed && f.routedTicks > 0) {
            f.routedTicks--;
            f.aiState = 'Fleeing';
            
            // PANIC SCATTER - random chaotic movement!
            // Each tick, pick a new random direction (with slight bias away from enemies)
            if (!f.panicAngle || m.rng.n() < 0.3) {
                // 30% chance to change panic direction each tick
                f.panicAngle = m.rng.n() * Math.PI * 2; // Random angle
                // Bias slightly toward own side
                const biasAngle = f.team === 0 ? Math.PI : 0;
                f.panicAngle = f.panicAngle * 0.6 + biasAngle * 0.4;
            }
            
            // Erratic speed - sometimes freeze in terror, sometimes sprint
            const panicSpeed = m.rng.n() < 0.2 ? 0.01 : (0.02 + m.rng.n() * 0.03);
            const dx = Math.cos(f.panicAngle) * panicSpeed;
            const dy = Math.sin(f.panicAngle) * panicSpeed;
            
            // Bounce off walls chaotically
            let newX = f.x + dx;
            let newY = f.y + dy;
            if (newX < 0.05 || newX > 0.95) f.panicAngle = Math.PI - f.panicAngle;
            if (newY < 0.05 || newY > 0.95) f.panicAngle = -f.panicAngle;
            
            f.x = Math.max(0.03, Math.min(0.97, newX));
            f.y = Math.max(0.05, Math.min(0.95, newY));
            
            // Chance to rally (recover from rout)
            if (m.rng.n() < 0.03) { // 3% chance per tick to rally
                f.routed = false;
                f.panicAngle = null;
                f.aiState = 'Rallying';
                showDmg(f.x, f.y, 'üí™RALLIED', 'buff');
                log(`üí™ ${fname(f)} rallies!`, 'buff');
            }
            return; // Skip normal AI while routed
        }
        if (f.routedTicks <= 0) f.routed = false;
        
        // KING RALLY AURA - allies within range get combat bonus
        const myKing = kings.find(k => k.team === f.team && k.alive);
        let rallyBonus = 0;
        if (myKing && !f.king) {
            const kingDist = Math.hypot(f.x - myKing.x, f.y - myKing.y);
            if (kingDist < 0.2) {
                rallyBonus = 0.25;
                f.aiState = f.aiState === 'Idle' ? 'Rallied' : f.aiState;
            }
        }
        f.rallyBonus = rallyBonus;
        
        // Battle flow awareness
        const teamAdvantage = m.teams[f.team].advantage;
        const isWinning = teamAdvantage > 0.15;
        const isLosing = teamAdvantage < -0.15;
        
        // ATTRIBUTE-DRIVEN PLAYSTYLE
        // High ATK = aggressive, High DEF = defensive, High SPD = flanker
        const atkRatio = f.atk / (f.atk + f.def);
        const isAggressive = atkRatio > 0.6 || f.personality === 'Aggressive' || f.personality === 'Reckless';
        const isDefensive = atkRatio < 0.45 || f.personality === 'Defensive' || f.personality === 'Cautious';
        const isFlanker = f.spd > 1.2;
        
        // GROUPING - tendency to stay near allies (WoW-style coordination)
        const centroid = teamCentroid[f.team];
        const distFromGroup = Math.hypot(f.x - centroid.x, f.y - centroid.y);
        const tooSpreadOut = distFromGroup > 0.25;
        
        // PEELING CHECK - tanks look for threatened allies
        let peelTarget = null;
        if (f.role === 'Tank' && !f.king) {
            const threatened = allies.filter(a => 
                (a.role === 'Mage' || a.role === 'Cleric' || a.king) && 
                a.hp < a.maxHp * 0.5 &&
                enemies.some(e => Math.hypot(e.x - a.x, e.y - a.y) < 0.1)
            );
            if (threatened.length) {
                peelTarget = threatened.reduce((best, a) => 
                    (a.hp < best.hp) ? a : best, threatened[0]);
            }
        }
        
        // Role-based behavior
        const isTank = f.role === 'Tank';
        const isBerserker = f.role === 'Berserker';
        const isPaladin = f.role === 'Paladin';
        const isRanged = f.role === 'Mage';
        const isHealer = f.role === 'Cleric' || f.role === 'Paladin'; // Paladins can heal too
        const isRogue = f.role === 'Rogue';
        const isBard = f.role === 'Bard';
        const isNecro = f.role === 'Necromancer';
        const range = isRanged ? 0.25 : (isBard || isNecro ? 0.20 : 0.06);
        
        // COMBAT ENGAGEMENT CHECK - don't waste abilities until combat is real
        const closestEnemy = enemies.reduce((best, e) => 
            dist(f, e) < dist(f, best) ? e : best, enemies[0]);
        const closestEnemyDist = closestEnemy ? dist(f, closestEnemy) : 1;
        const combatEngaged = m.tick > 12 && closestEnemyDist < 0.35; // Wait 12 ticks AND enemy within 0.35
        const combatUrgent = closestEnemyDist < 0.15; // Enemy very close - act now!
        
        // GAP CLOSERS - Melee charge abilities!
        if (f.chargeCd > 0) f.chargeCd--;
        const canCharge = f.chargeCd <= 0 && closestEnemy && closestEnemyDist > 0.1 && closestEnemyDist < 0.3 && combatEngaged;
        
        // SHIELD RUSH - Tanks dash and stun
        if (isTank && canCharge && m.rng.n() < 0.4) {
            const rushDist = Math.min(0.12, closestEnemyDist - 0.04);
            const angle = Math.atan2(closestEnemy.y - f.y, closestEnemy.x - f.x);
            f.x += Math.cos(angle) * rushDist;
            f.y += Math.sin(angle) * rushDist;
            f.chargeCd = 20; // 12 second cooldown
            closestEnemy.buffs.push({name:'Stunned', icon:'üí´', duration:3, spdMult:0.3});
            f.aiState = 'Shield Rush';
            showDmg(f.x, f.y, 'üõ°Ô∏è SHIELD RUSH!', 'buff');
            log(`üõ°Ô∏è ${fname(f)} SHIELD RUSHES ${fname(closestEnemy)}!`, 'buff');
        }
        
        // CHARGE - Berserkers leap with bonus damage
        if (isBerserker && canCharge && m.rng.n() < 0.5) {
            const chargeDist = Math.min(0.15, closestEnemyDist - 0.03);
            const angle = Math.atan2(closestEnemy.y - f.y, closestEnemy.x - f.x);
            f.x += Math.cos(angle) * chargeDist;
            f.y += Math.sin(angle) * chargeDist;
            f.chargeCd = 15; // 10 second cooldown
            f.buffs.push({name:'Charging', icon:'‚ö°', duration:3, atkBonus:8});
            f.aiState = 'Charging';
            showDmg(f.x, f.y, '‚ö° CHARGE!', 'crit');
            log(`‚ö° ${fname(f)} CHARGES into battle!`, 'crit');
        }
        
        // HOLY RUSH - Paladins dash and heal nearby allies
        if (isPaladin && canCharge && f.mana >= 15 && m.rng.n() < 0.4) {
            const rushDist = Math.min(0.12, closestEnemyDist - 0.04);
            const angle = Math.atan2(closestEnemy.y - f.y, closestEnemy.x - f.x);
            f.x += Math.cos(angle) * rushDist;
            f.y += Math.sin(angle) * rushDist;
            f.chargeCd = 18;
            f.mana -= 15;
            // Heal nearby allies on landing
            const nearbyAllies = allies.filter(a => Math.hypot(a.x - f.x, a.y - f.y) < 0.12);
            nearbyAllies.forEach(a => {
                const heal = 15 + Math.floor(m.rng.n() * 10);
                a.hp = Math.min(a.maxHp, a.hp + heal);
                showDmg(a.x, a.y, `+${heal}`, 'heal');
            });
            f.aiState = 'Holy Rush';
            showDmg(f.x, f.y, '‚úùÔ∏è HOLY RUSH!', 'heal');
            log(`‚úùÔ∏è ${fname(f)} HOLY RUSHES, healing ${nearbyAllies.length} allies!`, 'buff');
        }
        
        // ROGUE STEALTH - can enter stealth when out of combat for 8+ ticks (long cooldown)
        if (isRogue && !f.invisible && f.stealthCooldown <= 0) {
            const ticksSinceCombat = m.tick - (f.lastCombatTick || 0);
            if (ticksSinceCombat >= 8) { // Out of combat for ~5 seconds
                // Enter stealth! Seek a target to backstab
                f.invisible = true;
                f.invisTicks = 11; // 7 seconds max
                f.buffs.push({name:'Shadowmeld', icon:'üë§', duration:11, special:'invisible'});
                f.aiState = 'üë§ Stalking';
                showDmg(f.x, f.y, 'üë§ STEALTH', 'buff');
                log(`üë§ ${fname(f)} vanishes into the shadows...`, 'buff');
            }
        }
        // Tick down stealth cooldown
        if (f.stealthCooldown > 0) f.stealthCooldown--;
        
        // Find target
        let target = null;
        let targetDist = Infinity;
        
        if (isHealer) {
            // Healers prioritize: 1) Heal wounded, 2) Buff unbuffed allies, 3) Attack
            const wounded = allies.filter(a => a.hp < a.maxHp * 0.6);
            const unbuffed = allies.filter(a => a.buffs.length === 0 && a.buffCd <= 0 && a.role !== 'Cleric');
            
            // Try to heal wounded first (8 tick cooldown) - always heal if someone is hurt
            if (wounded.length && f.healCd <= 0 && (combatEngaged || combatUrgent) && m.rng.n() < 0.7) {
                wounded.forEach(a => {
                    const d = dist(f, a);
                    if (d < targetDist) { targetDist = d; target = a; }
                });
                if (target && targetDist < 0.18) {
                    f.aiState = 'Healing';
                    f.currentTarget = target.uid; // Track healing target
                    f.healCd = 8; // 8 tick cooldown
                    const heal = Math.floor(25 + m.rng.n() * 15); // Stronger but less frequent
                    target.hp = Math.min(target.maxHp, target.hp + heal);
                    f.healDone += heal;
                    showDmg(target.x, target.y, `+${heal}`, 'heal');
                    showSpell(target.x, target.y, 'holy'); // Golden heal effect
                    return;
                }
            }
            
            // Try to buff an ally (12 tick cooldown) - only when combat is engaged
            if (unbuffed.length && f.buffCdSelf <= 0 && combatEngaged && m.rng.n() < 0.5) {
                let buffTarget = null;
                let buffDist = Infinity;
                unbuffed.forEach(a => {
                    const d = dist(f, a);
                    if (d < buffDist) { buffDist = d; buffTarget = a; }
                });
                if (buffTarget && buffDist < 0.2) {
                    f.aiState = 'Buffing';
                    f.currentTarget = buffTarget.uid; // Track buff target
                    f.buffCdSelf = 12; // 12 tick cooldown
                    // Apply a random buff
                    const buffTypes = [
                        {name:'Blessing', icon:'‚ú®', duration:10, atkBonus:6, defBonus:0},
                        {name:'Shield', icon:'üõ°Ô∏è', duration:8, atkBonus:0, defBonus:6},
                        {name:'Haste', icon:'‚ö°', duration:6, spdBonus:0.35, atkBonus:0, defBonus:0},
                        {name:'Might', icon:'üí™', duration:9, atkBonus:10, defBonus:0},
                    ];
                    const buff = buffTypes[Math.floor(m.rng.n() * buffTypes.length)];
                    buffTarget.buffs.push({...buff});
                    buffTarget.buffCd = 15; // Target can't receive another buff for 15 ticks
                    showDmg(buffTarget.x, buffTarget.y, buff.icon + buff.name, 'buff');
                    showSpell(buffTarget.x, buffTarget.y, 'holy'); // Buff effect
                    log(`‚ú® ${fname(f)} casts ${buff.name} on ${fname(buffTarget)}!`, 'buff');
                    return;
                }
            }
            f.aiState = f.healCd > 0 || f.buffCdSelf > 0 ? 'Cooldown' : 'Supporting';
        }
        
        // BARD - D&D 5e inspired: Bardic Inspiration, Vicious Mockery, backline drummer
        if (isBard) {
            // PASSIVE DRUM AURA - allies nearby get +3 ATK (every tick)
            allies.forEach(a => {
                if (a !== f && dist(f, a) < 0.15) {
                    if (!a.drumBuff) {
                        a.drumBuff = true;
                        a.atk += 3;
                    }
                }
            });
            
            // BARDIC INSPIRATION - single target big buff (12 tick cd) - wait for combat
            if (f.buffCdSelf <= 0 && f.mana >= 20 && combatEngaged && m.rng.n() < 0.6) {
                const unbuffed = allies.filter(a => a !== f && !a.inspired && a.buffCd <= 0);
                if (unbuffed.length) {
                    const inspTarget = unbuffed.reduce((best, a) => 
                        (a.king || a.role === 'Berserker') && !best.king ? a : 
                        dist(f, a) < dist(f, best) ? a : best, unbuffed[0]);
                    if (dist(f, inspTarget) < 0.25) {
                        f.mana -= 20;
                        f.buffCdSelf = 12;
                        inspTarget.inspired = true;
                        inspTarget.buffs.push({name:'Inspired', icon:'üéµ', duration:15, atkBonus:8, defBonus:4, spdBonus:0.15});
                        inspTarget.buffCd = 20;
                        showDmg(inspTarget.x, inspTarget.y, 'üéµ INSPIRED!', 'buff');
                        log(`üéµ ${fname(f)} inspires ${fname(inspTarget)} with a heroic melody!`, 'buff');
                        f.aiState = 'Inspiring';
                        return;
                    }
                }
            }
            
            // VICIOUS MOCKERY - psychic damage + debuff enemy (8 tick cd) - only in combat
            if (f.healCd <= 0 && f.mana >= 15 && combatEngaged && m.rng.n() < 0.5) {
                const mockTarget = enemies.reduce((best, e) => 
                    dist(f, e) < dist(f, best) ? e : best, enemies[0]);
                if (mockTarget && dist(f, mockTarget) < 0.22) {
                    f.mana -= 15;
                    f.healCd = 8; // Reusing healCd as ability cd
                    const psychicDmg = Math.floor(8 + m.rng.n() * 8);
                    mockTarget.hp -= psychicDmg;
                    mockTarget.atk = Math.max(5, mockTarget.atk - 3); // Debuff ATK
                    mockTarget.mockeryDebuff = 6; // Lasts 6 ticks
                    showDmg(mockTarget.x, mockTarget.y, `üó£Ô∏è-${psychicDmg}`, 'magic');
                    showSpell(mockTarget.x, mockTarget.y, 'shadow'); // Purple psychic effect
                    log(`üó£Ô∏è ${fname(f)} mocks ${fname(mockTarget)} viciously! Psychic damage rends their mind! [${psychicDmg}]`, 'magic');
                    f.aiState = 'Mocking';
                    if (mockTarget.hp <= 0) {
                        mockTarget.alive = false;
                        f.kills++;
                        log(`üíÄ ${fname(mockTarget)} dies of shame from ${fname(f)}'s cutting words!`, 'kill');
                    }
                    return;
                }
            }
            f.aiState = 'ü•Å Drumming';
        }
        
        // NECROMANCER - summon skeletons, raise the dead
        if (isNecro) {
            const deadAllies = m.teams[f.team].f.filter(a => !a.alive && !a.raised);
            const deadEnemies = m.teams[1-f.team].f.filter(e => !e.alive && !e.raised);
            const allDead = [...deadAllies, ...deadEnemies];
            
            // Track kills for skeleton summoning
            if (!f.lastKills) f.lastKills = 0;
            const newKills = f.kills - f.lastKills;
            if (newKills > 0 && f.summons < 3) {
                f.summons = Math.min(3, f.summons + newKills);
                f.lastKills = f.kills;
            }
            
            // SUMMON SKELETON - on kill, up to 3 (costs 15 mana each) - only after combat starts
            if (f.summons > 0 && f.mana >= 15 && f.spellCd <= 0 && combatEngaged) {
                f.mana -= 15;
                f.spellCd = 6;
                f.summons--;
                // Create skeleton minion
                const skeleton = {
                    id: 0, uid: `skel-${f.team}-${m.tick}-${m.rng.n().toString(36).slice(2,5)}`,
                    name: 'üíÄ Skeleton', role: 'Minion', trait: 'Undead',
                    hp: 60, maxHp: 60, atk: 12, def: 3, spd: 1.1,
                    alive: true, team: f.team, king: false,
                    x: f.x + (m.rng.n() - 0.5) * 0.08,
                    y: f.y + (m.rng.n() - 0.5) * 0.08,
                    kills: 0, dmgDone: 0, dmgTaken: 0, healDone: 0,
                    buffs: [], buffCd: 0, personality: 'Aggressive',
                    shieldDir: 0, aiState: 'Summoned', idleTime: 0,
                    healCd: 0, buffCdSelf: 0, spellCd: 0, specialCd: 0, atkCd: 0, rallyCd: 0,
                    mana: 0, maxMana: 0, isSummon: true, gear: {weapon:'Bone Claws', armor:'Tattered Rags', accessory:'None'}
                };
                m.teams[f.team].f.push(skeleton);
                showDmg(skeleton.x, skeleton.y, 'üíÄ RISE!', 'magic');
                showSpell(skeleton.x, skeleton.y, 'shadow'); // Dark summon effect
                log(`üíÄ ${fname(f)} summons a Skeleton from the grave!`, 'magic');
                f.aiState = 'Summoning';
                return;
            }
            
            // RAISE DEAD - resurrect a fallen fighter (30 tick cd, 40 mana) - EPIC EVENT!
            // Difficulty scales with target power: low-level allies easy, enemies/kings hard
            // MAX 2 RAISES PER NECROMANCER PER MATCH
            if (f.raiseCd <= 0 && f.mana >= 40 && allDead.length > 0 && combatEngaged && (f.raisesCount || 0) < 2) {
                // Sort corpses by ease of resurrection (allies first, low power first)
                const sortedDead = allDead.sort((a, b) => {
                    const aIsEnemy = a.team !== f.team;
                    const bIsEnemy = b.team !== f.team;
                    const aPower = a.maxHp + a.atk * 5;
                    const bPower = b.maxHp + b.atk * 5;
                    // Prefer allies, then prefer weaker targets
                    if (aIsEnemy !== bIsEnemy) return aIsEnemy ? 1 : -1;
                    return aPower - bPower;
                });
                
                const corpse = sortedDead[0]; // Pick easiest target
                if (dist(f, corpse) < 0.25) {
                    // Calculate resurrection difficulty
                    const wasEnemy = corpse.team !== f.team;
                    const wasLeader = corpse.rank || corpse.king;
                    const power = (corpse.maxHp + corpse.atk * 5) / 400; // Normalized power 0-1ish
                    
                    // Base chance: 50% for weak allies, scales down with power
                    let raiseChance = 0.5 - (power * 0.25); // Weaker = easier
                    
                    // 1.25x harder for enemies (divide chance by 1.25 = multiply by 0.8)
                    if (wasEnemy) raiseChance *= 0.8;
                    
                    // Leaders are much harder to control
                    if (corpse.rank === 'Captain') raiseChance *= 0.7;
                    if (corpse.rank === 'General') raiseChance *= 0.5;
                    if (corpse.king) raiseChance *= 0.3; // Kings resist strongly!
                    
                    // Minimum 5% chance, max 50%
                    raiseChance = Math.max(0.05, Math.min(0.5, raiseChance));
                    
                    if (m.rng.n() < raiseChance) {
                        f.mana -= 40;
                        f.raiseCd = 30;
                        f.raisesCount = (f.raisesCount || 0) + 1; // Track total raises (max 2)
                    
                    // Resurrect with reduced stats, now on necro's team
                    corpse.alive = true;
                    corpse.raised = true;
                    const originalTeam = corpse.team;
                    corpse.team = f.team; // Now fights for necromancer
                    corpse.hp = Math.floor(corpse.maxHp * 0.5);
                    corpse.atk = Math.floor(corpse.atk * 0.7);
                    corpse.aiState = 'Reanimated';
                    const oldName = corpse.name.replace(/^üßü /, '');
                    corpse.name = `üßü ${oldName}`;
                    
                    // Move to necro's team array if switching sides
                    if (!m.teams[f.team].f.includes(corpse)) {
                        m.teams[1-f.team].f = m.teams[1-f.team].f.filter(x => x !== corpse);
                        m.teams[f.team].f.push(corpse);
                    }
                    
                    // === EPIC VISUAL EFFECTS ===
                    // 1. Big screen shake!
                    screenShake('big');
                    
                    // 2. Multiple dramatic damage numbers
                    showDmg(corpse.x, corpse.y - 0.05, 'üíÄ', 'magic');
                    setTimeout(() => showDmg(corpse.x, corpse.y, '‚ö° RISE ‚ö°', 'magic'), 200);
                    setTimeout(() => showDmg(corpse.x, corpse.y + 0.05, 'üßü', 'magic'), 400);
                    
                    // 3. Purple spell effect at both caster and corpse
                    showSpell(f.x, f.y, 'shadow');
                    showSpell(corpse.x, corpse.y, 'shadow');
                    
                    // === EPIC LOG MESSAGES ===
                    log(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`, 'king');
                    if (wasEnemy && wasLeader) {
                        log(`üíÄ‚ö° LEGENDARY RESURRECTION! ‚ö°üíÄ`, 'king');
                        log(`üßü ${fname(f)} RAISES THE ENEMY ${corpse.rank || 'CHAMPION'} FROM THE GRAVE!`, 'king');
                        log(`${oldName} NOW FIGHTS FOR THE OTHER SIDE!`, 'king');
                    } else if (wasEnemy) {
                        log(`üíÄ DARK BETRAYAL! üíÄ`, 'king');
                        log(`üßü ${fname(f)} raises fallen enemy ${oldName}!`, 'king');
                        log(`The dead now serve a new master!`, 'magic');
                    } else if (wasLeader) {
                        log(`‚ö° THE FALLEN RETURNS! ‚ö°`, 'king');
                        log(`üßü ${fname(f)} resurrects ${corpse.rank || ''} ${oldName}!`, 'king');
                    } else {
                        log(`üßü ${fname(f)} raises ${oldName} from the dead!`, 'magic');
                    }
                    log(`‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê`, 'king');
                    
                    f.aiState = 'Raising Dead';
                        return;
                    } else {
                        // Failed resurrection attempt - corpse resists!
                        f.mana -= 20; // Still costs some mana
                        f.raiseCd = 15; // Shorter cooldown on fail
                        showDmg(corpse.x, corpse.y, '‚ùå RESISTS', 'info');
                        if (corpse.king) {
                            log(`üíÄ ${fname(f)} fails to raise the fallen ruler - the royal will is too strong!`, 'magic');
                        } else if (wasEnemy) {
                            log(`üíÄ ${fname(f)}'s dark magic fails - the enemy spirit resists!`, 'info');
                        } else {
                            log(`üíÄ ${fname(f)}'s resurrection fails...`, 'info');
                        }
                        f.aiState = 'Failed Raise';
                        return;
                    }
                }
            }
            if (f.raiseCd > 0) f.raiseCd--;
            
            f.aiState = 'üíÄ Channeling';
        }
        
        // Find enemy target
        if (isRogue) {
            // Rogues try to flank - target ranged/healers (squishies)
            const priority = enemies.filter(e => e.role === 'Mage' || e.role === 'Cleric' || e.role === 'Bard');
            const targets = priority.length ? priority : enemies;
            // When stealthed, prefer isolated/distracted targets
            if (f.invisible) {
                // Find enemy engaged with someone else (distracted)
                const distracted = targets.filter(e => {
                    const nearbyAllies = allies.filter(a => dist(a, e) < 0.08 && a !== f);
                    return nearbyAllies.length > 0; // Enemy is fighting someone
                });
                (distracted.length ? distracted : targets).forEach(e => {
                    const d = dist(f, e);
                    if (d < targetDist) { targetDist = d; target = e; }
                });
                f.aiState = 'üë§ Stalking';
            } else {
                targets.forEach(e => {
                    const d = dist(f, e);
                    if (d < targetDist) { targetDist = d; target = e; }
                });
            }
        } else if (isTank) {
            // Tanks target nearest enemy, but prioritize threats to squishies
            const threats = enemies.filter(e => {
                const nearSquishy = allies.some(a => 
                    (a.role === 'Mage' || a.role === 'Cleric') && dist(e, a) < 0.12);
                return nearSquishy;
            });
            (threats.length > 0 ? threats : enemies).forEach(e => {
                const d = dist(f, e);
                if (d < targetDist) { targetDist = d; target = e; }
            });
        } else {
            // SMART TARGETING: Focus fire wounded enemies (< 40% HP) if nearby
            const wounded = enemies.filter(e => e.hp < e.maxHp * 0.4 && dist(f, e) < 0.2);
            // Also prioritize high-value targets (kings, healers)
            const priority = enemies.filter(e => e.king || e.role === 'Cleric');
            const targets = wounded.length > 0 ? wounded : (priority.length > 0 ? priority : enemies);
            targets.forEach(e => {
                const d = dist(f, e);
                // Weight by HP% - lower HP = higher priority
                const hpWeight = e.hp / e.maxHp;
                const effectiveDist = d * (0.5 + hpWeight * 0.5);
                if (effectiveDist < targetDist) { targetDist = effectiveDist; target = e; }
            });
        }
        
        if (!target) return;
        
        // Store current target for inspector display
        f.currentTarget = target.uid;
        
        // Check line of sight for ranged
        const hasLOS = !isRanged || checkLOS(f.x, f.y, target.x, target.y);
        
        if (targetDist <= range && hasLOS) {
            // ATTACK COOLDOWN - slower, more deliberate combat
            if (f.atkCd > 0) {
                f.aiState = isRanged ? 'Channeling' : 'Attacking';
                return; // Still recovering from last attack
            }
            
            // MANA CHECK for casters - can't cast without mana!
            const spellCost = isRanged ? 25 : (isHealer ? 20 : 0);
            if (spellCost > 0 && f.mana < spellCost) {
                f.aiState = 'Out of Mana';
                // Fall back to weak melee
                if (targetDist > 0.08) return; // Too far for melee backup
            }
            
            // Mages have additional spell cooldown
            if (isRanged && f.spellCd > 0) {
                f.aiState = 'Channeling';
                return;
            }
            
            // LOS blocked feedback for casters
            if (isRanged && !hasLOS) {
                f.aiState = 'No Line of Sight';
                showDmg(f.x, f.y, '‚ùå BLOCKED', 'block');
                return;
            }
            
            // Attack! Set AI state
            f.aiState = isRanged ? 'Casting' : 'Attacking';
            f.idleTime = 0;
            
            // Consume mana for spells
            if (spellCost > 0 && f.mana >= spellCost) {
                f.mana -= spellCost;
            }
            
            // Set attack cooldown (varies by role - faster roles attack quicker)
            const atkCooldowns = {Tank: 3, Berserker: 2, Rogue: 2, Mage: 4, Cleric: 3};
            f.atkCd = atkCooldowns[f.role] || 3;
            
            // Mages get additional spell cooldown
            if (isRanged) f.spellCd = 3;
            
            // Calculate with buff bonuses + rally aura
            const atkBonus = f.buffs.reduce((sum, b) => sum + (b.atkBonus || 0), 0);
            const defBonus = target.buffs.reduce((sum, b) => sum + (b.defBonus || 0), 0);
            const rallyAtk = f.rallyBonus ? Math.floor(f.atk * f.rallyBonus) : 0;
            const rallyDef = f.rallyBonus ? Math.floor(f.def * f.rallyBonus) : 0;
            let base = (f.atk + atkBonus + rallyAtk) * (0.8 + m.rng.n() * 0.4);
            let def = (target.def + defBonus + (target.rallyBonus ? Math.floor(target.def * target.rallyBonus) : 0)) * 0.5;
            
            // SHIELD BLOCKING for tanks (270 degree arc)
            let blocked = false;
            if (target.role === 'Tank' && target.alive) {
                // Calculate attack angle
                const attackAngle = Math.atan2(f.y - target.y, f.x - target.x);
                // Shield faces toward enemies (adjust based on attacker position)
                target.shieldDir = attackAngle; // Tank turns shield toward attacker
                // Check if attack is within 270 degree block arc (135 degrees each side)
                const shieldArc = Math.PI * 0.75; // 135 degrees = 270/2
                const angleDiff = Math.abs(Math.atan2(Math.sin(attackAngle - target.shieldDir), Math.cos(attackAngle - target.shieldDir)));
                if (angleDiff < shieldArc && m.rng.n() < 0.4) { // 40% block chance when in arc
                    blocked = true;
                    def *= 2.5; // Massive defense boost when blocking
                    target.aiState = 'Blocking';
                    showDmg(target.x, target.y, 'üõ°Ô∏èBLOCK', 'block');
                }
            }
            
            let dmg = Math.max(1, Math.floor(base - def));
            const crit = m.rng.n() < 0.06;
            if (crit && !blocked) dmg = Math.floor(dmg * 2);
            dmg = Math.floor(dmg * (0.7 + m.teams[f.team].morale/100 * 0.5));
            
            // ROGUE BACKSTAB - breaking stealth with an attack = massive bonus!
            let isBackstab = false;
            if (isRogue && f.invisible) {
                isBackstab = true;
                dmg = Math.floor(dmg * 2.5); // 250% damage on backstab opener!
                // Break stealth
                f.invisible = false;
                f.invisTicks = 0;
                f.stealthCooldown = 45; // Can't re-stealth for ~30 seconds - use it wisely!
                f.buffs = f.buffs.filter(b => b.special !== 'invisible');
                showDmg(target.x, target.y, 'üó°Ô∏è BACKSTAB!', 'backstab');
                log(`üó°Ô∏è ${fname(f)} strikes from the shadows! BACKSTAB on ${fname(target)}!`, 'crit');
                screenShake('normal');
            }
            
            // RIPOSTE chance (20-35% based on target's DEF) - can't riposte backstabs
            const riposteChance = 0.15 + (target.def / 100);
            const isRiposte = !blocked && !isBackstab && m.rng.n() < riposteChance && target.role !== 'Mage';
            let riposteDmg = 0;
            if (isRiposte) {
                riposteDmg = Math.floor(target.atk * 0.3 * (0.8 + m.rng.n() * 0.4));
                f.hp -= riposteDmg;
                f.dmgTaken += riposteDmg;
                target.dmgDone += riposteDmg;
                showDmg(f.x, f.y, riposteDmg, 'riposte');
                // Combat tracking for riposte
                f.lastCombatTick = m.tick;
                target.lastCombatTick = m.tick;
            }
            
            target.hp -= dmg;
            target.dmgTaken += dmg;
            f.dmgDone += dmg;
            
            // Track combat for stealth mechanics
            f.lastCombatTick = m.tick;
            target.lastCombatTick = m.tick;
            
            if (!blocked) {
                showDmg(target.x, target.y, dmg, crit ? 'crit' : '');
                // Hit markers - melee gets boom, ranged gets spell effect
                if (isRanged) {
                    showSpell(target.x, target.y, 'fire');
                } else {
                    showHit(target.x, target.y, crit);
                }
            }
            
            // DWARF FORTRESS-STYLE COMBAT LOG
            combatLog(f, target, dmg, crit, blocked, isRiposte);
            
            if (target.hp <= 0) {
                target.alive = false;
                target.aiState = 'Dead';
                f.kills++;
                const tt = m.teams[target.team];
                // Death effects
                spawnDeathMarker(target.x, target.y); // Skull + blood on ground
                showDmg(target.x, target.y, 'üíÄ SLAIN', 'lethal');
                
                // === LOOT DROP SYSTEM ===
                // Slayer absorbs power from the fallen (RNG stat boost)
                const lootRoll = m.rng.n();
                const targetPower = (target.maxHp + target.atk * 5 + target.def * 3) / 100; // Power scaling
                const lootChance = Math.min(0.6, 0.3 + targetPower * 0.1); // Stronger enemies = better loot chance
                
                if (lootRoll < lootChance && !f.isSummon) {
                    const lootType = m.rng.n();
                    let lootMsg = '';
                    let lootIcon = '';
                    
                    if (lootType < 0.3) {
                        // HP boost
                        const hpGain = Math.floor(5 + target.maxHp * 0.05);
                        f.hp = Math.min(f.maxHp + hpGain, f.hp + hpGain);
                        f.maxHp += Math.floor(hpGain * 0.5);
                        lootIcon = '‚ù§Ô∏è';
                        lootMsg = `+${hpGain} HP`;
                    } else if (lootType < 0.55) {
                        // Attack boost
                        const atkGain = Math.floor(1 + target.atk * 0.08);
                        f.atk += atkGain;
                        lootIcon = '‚öîÔ∏è';
                        lootMsg = `+${atkGain} ATK`;
                    } else if (lootType < 0.75) {
                        // Defense boost
                        const defGain = Math.floor(1 + target.def * 0.1);
                        f.def += defGain;
                        lootIcon = 'üõ°Ô∏è';
                        lootMsg = `+${defGain} DEF`;
                    } else if (lootType < 0.9) {
                        // Speed boost
                        const spdGain = 0.03 + m.rng.n() * 0.05;
                        f.spd += spdGain;
                        lootIcon = 'üí®';
                        lootMsg = `+SPD`;
                    } else {
                        // Mana boost (for casters) or crit buff
                        if (f.maxMana > 0) {
                            const manaGain = 15 + Math.floor(m.rng.n() * 15);
                            f.mana = Math.min(f.maxMana, f.mana + manaGain);
                            lootIcon = '‚ú®';
                            lootMsg = `+${manaGain} MANA`;
                        } else {
                            f.atk += 2;
                            f.def += 1;
                            lootIcon = 'üíÄ';
                            lootMsg = `POWER`;
                        }
                    }
                    
                    // Visual feedback for loot
                    setTimeout(() => {
                        showDmg(f.x, f.y - 0.03, `${lootIcon} ${lootMsg}`, 'heal');
                    }, 300);
                    
                    // Epic loot from leaders
                    if (target.king || target.rank) {
                        f.atk += 2;
                        f.def += 1;
                        f.maxHp += 10;
                        setTimeout(() => {
                            showDmg(f.x, f.y, 'üëë GLORY', 'crit');
                        }, 500);
                        log(`${lootIcon} ${fname(f)} absorbs ${target.king ? 'royal' : 'champion'} power! ${lootMsg} + GLORY BONUS!`, 'magic');
                    } else {
                        log(`${lootIcon} ${fname(f)} absorbs power from the fallen: ${lootMsg}`, 'info');
                    }
                }
                
                if (target.king) {
                    tt.kingAlive = false;
                    tt.morale = Math.max(0, tt.morale - 50);
                    m.teams[1-target.team].morale = Math.min(100, m.teams[1-target.team].morale + 20);
                    screenShake('big');
                    log(`${target.rankIcon || 'üíÄ'}üíÄ ${target.rank || 'Leader'} ${target.name} HAS FALLEN! Their army wavers!`, 'king');
                } else {
                    tt.morale = Math.max(0, tt.morale - 2);
                    log(`üíÄ ${fname(target)}'s body crumples to the ground. ${fname(f)} claims the kill.`, 'kill');
                }
            }
            
            // Check if riposte killed attacker
            if (isRiposte && f.hp <= 0) {
                f.alive = false;
                f.aiState = 'Dead';
                target.kills++;
                spawnDeathMarker(f.x, f.y); // Skull + blood on ground
                const at = m.teams[f.team];
                if (f.king) {
                    at.kingAlive = false;
                    at.morale = Math.max(0, at.morale - 50);
                    log(`${f.rankIcon || 'üíÄ'}üíÄ ${f.rank || 'Leader'} ${f.name} falls to a riposte! The tide turns!`, 'king');
                } else {
                    at.morale = Math.max(0, at.morale - 2);
                    log(`‚öîÔ∏è ${fname(target)}'s riposte proves fatal! ${fname(f)} falls!`, 'riposte');
                }
            }
        } else {
            // Movement - battle-aware + personality-driven
            let tx = target.x, ty = target.y;
            const isReckless = f.personality === 'Reckless' || f.personality === 'Berserker' || f.personality === 'Aggressive';
            const isCautious = f.personality === 'Cautious' || f.personality === 'Defensive';
            
            // BATTLE FLOW affects aggression
            const aggression = isWinning ? 1.3 : (isLosing ? 0.85 : 1.0);
            
            // KINGS - CLASS-BASED BEHAVIOR!
            if (f.king) {
                const myMorale = m.teams[f.team].morale;
                const enemyMorale = m.teams[1-f.team].morale;
                const moraleLead = myMorale - enemyMorale;
                const kingRole = f.role;
                
                // WARRIOR KINGS (Tank, Berserker) - Lead from the front!
                if (kingRole === 'Tank' || kingRole === 'Berserker') {
                    if (myMorale >= 70) {
                        if (f.aiState !== 'Leading Charge') battleCry(f, 'charge');
                        f.aiState = 'Leading Charge';
                        tx = target.x;
                        ty = target.y;
                        const push = f.team === 0 ? 0.03 : -0.03;
                        tx += push;
                    } else if (myMorale >= 40) {
                        if (f.aiState !== 'Rallying') battleCry(f, 'rally');
                        f.aiState = 'Rallying';
                        tx = target.x;
                        ty = target.y;
                    } else {
                        if (f.aiState !== 'Last Stand') battleCry(f, 'lastStand');
                        f.aiState = 'Last Stand';
                        tx = target.x;
                        ty = target.y;
                    }
                    // Warrior kings push forward
                    const minX = f.team === 0 ? 0.35 : 0;
                    const maxX = f.team === 0 ? 1 : 0.65;
                    if (f.team === 0 && f.x < minX) {
                        tx = Math.max(tx, 0.45);
                        f.aiState = 'Advancing';
                    } else if (f.team === 1 && f.x > maxX) {
                        tx = Math.min(tx, 0.55);
                        f.aiState = 'Advancing';
                    }
                }
                // CASTER KINGS (Mage, Necromancer) - Stay back, cast from safety!
                else if (kingRole === 'Mage' || kingRole === 'Necromancer') {
                    const safeX = f.team === 0 ? 0.15 : 0.85; // Far back
                    const hasTanks = allies.some(a => a.role === 'Tank' && a.alive);
                    
                    if (myMorale >= 60 && hasTanks) {
                        // Safe to cast - stay behind tanks
                        if (f.aiState !== 'Commanding') battleCry(f, 'command');
                        f.aiState = 'Commanding';
                        tx = safeX;
                        // Kite if enemies get close
                        const nearestEnemy = enemies.reduce((n, e) => dist(f, e) < dist(f, n) ? e : n, enemies[0]);
                        if (nearestEnemy && dist(f, nearestEnemy) < 0.15) {
                            tx = f.team === 0 ? Math.max(0.08, f.x - 0.05) : Math.min(0.92, f.x + 0.05);
                            f.aiState = 'Retreating';
                        }
                    } else if (myMorale < 30) {
                        // Desperate - still fight but from range
                        if (f.aiState !== 'Last Stand') battleCry(f, 'lastStand');
                        f.aiState = 'Last Stand';
                        tx = safeX;
                    } else {
                        f.aiState = 'Casting';
                        tx = f.team === 0 ? 0.25 : 0.75;
                    }
                }
                // SUPPORT KINGS (Cleric, Bard) - Mid-line, keep army alive!
                else if (kingRole === 'Cleric' || kingRole === 'Bard') {
                    const midX = f.team === 0 ? 0.25 : 0.75;
                    const woundedAlly = allies.find(a => a.hp < a.maxHp * 0.5 && a.alive);
                    
                    if (woundedAlly) {
                        // Move toward wounded to heal/buff
                        if (f.aiState !== 'Supporting') battleCry(f, 'support');
                        f.aiState = 'Supporting';
                        tx = woundedAlly.x + (f.team === 0 ? -0.05 : 0.05);
                        ty = woundedAlly.y;
                    } else if (myMorale >= 50) {
                        if (f.aiState !== 'Inspiring') battleCry(f, 'rally');
                        f.aiState = 'Inspiring';
                        tx = midX;
                    } else {
                        if (f.aiState !== 'Last Stand') battleCry(f, 'lastStand');
                        f.aiState = 'Last Stand';
                        tx = midX;
                    }
                    // Never go past mid
                    if (f.team === 0) tx = Math.min(tx, 0.4);
                    else tx = Math.max(tx, 0.6);
                }
                // ROGUE KINGS - Sneaky assassin ruler!
                else if (kingRole === 'Rogue') {
                    const enemyKing = enemies.find(e => e.king);
                    if (f.invisible) {
                        // Hunt enemy king while stealthed
                        if (f.aiState !== 'üë§ Royal Assassin') battleCry(f, 'assassin');
                        f.aiState = 'üë§ Royal Assassin';
                        if (enemyKing) {
                            tx = enemyKing.x + (f.team === 0 ? 0.05 : -0.05);
                            ty = enemyKing.y;
                        }
                    } else if (myMorale >= 60) {
                        // Flank aggressively
                        if (f.aiState !== 'Flanking') battleCry(f, 'taunt');
                        f.aiState = 'Flanking';
                        tx = f.team === 0 ? 0.6 : 0.4;
                        ty = target.y > 0.5 ? 0.2 : 0.8; // Opposite side
                    } else {
                        if (f.aiState !== 'Hunting King') battleCry(f, 'assassin');
                        f.aiState = 'Hunting King';
                        if (enemyKing) {
                            tx = enemyKing.x;
                            ty = enemyKing.y;
                        }
                    }
                }
                // DEFAULT - generic fighters as king (shouldn't happen much)
                else {
                    if (myMorale >= 50) {
                        f.aiState = 'Rallying';
                        tx = f.team === 0 ? 0.35 : 0.65;
                    } else {
                        f.aiState = 'Last Stand';
                        tx = target.x;
                        ty = target.y;
                    }
                }
            }
            // TANKS - HOLD THE LINE! Stay at choke points, protect squishies
            else if (isTank) {
                // Find squishies to protect (mages, clerics, bards behind us)
                const squishies = allies.filter(a => 
                    (a.role === 'Mage' || a.role === 'Cleric' || a.role === 'Bard' || a.role === 'Necromancer') &&
                    (f.team === 0 ? a.x < f.x : a.x > f.x) // Behind tank
                );
                
                // PEEL - protect threatened allies!
                if (peelTarget) {
                    f.aiState = 'Peeling';
                    tx = peelTarget.x;
                    ty = peelTarget.y;
                    const threatToAlly = enemies.find(e => Math.hypot(e.x - peelTarget.x, e.y - peelTarget.y) < 0.1);
                    if (threatToAlly) target = threatToAlly;
                } 
                // HOLD POSITION - stay at front line, don't overextend
                else {
                    // Front line position - don't charge past mid
                    const frontLine = f.team === 0 ? 0.45 : 0.55;
                    const atFront = f.team === 0 ? f.x >= frontLine : f.x <= frontLine;
                    
                    if (atFront) {
                        // Hold position, intercept approaching enemies
                        f.aiState = 'Holding Line';
                        const approaching = enemies.filter(e => 
                            f.team === 0 ? e.x < 0.5 : e.x > 0.5
                        );
                        if (approaching.length > 0) {
                            const nearest = approaching.reduce((best, e) => 
                                dist(f, e) < dist(f, best) ? e : best);
                            // Move to intercept but don't overextend
                            tx = f.team === 0 ? Math.min(nearest.x - 0.05, frontLine) : Math.max(nearest.x + 0.05, frontLine);
                            ty = nearest.y;
                        } else {
                            tx = frontLine;
                        }
                    } else {
                        // Advance to front line
                        f.aiState = 'Advancing';
                        tx = frontLine;
                    }
                }
            }
            // ROGUES - hunt the enemy king!
            else if (isRogue) {
                const enemyKing = enemies.find(e => e.king);
                
                // STEALTHED - circle around to get behind target
                if (f.invisible) {
                    f.aiState = 'üë§ Stalking';
                    // Move to flank position (behind target relative to their team)
                    if (target) {
                        const behindX = target.team === 0 ? target.x - 0.08 : target.x + 0.08;
                        const flankY = target.y + (f.y > target.y ? 0.06 : -0.06);
                        tx = behindX;
                        ty = flankY;
                    }
                    // Avoid getting too close to enemies while circling (breaks stealth if detected)
                    const nearbyEnemy = enemies.filter(e => e !== target && dist(f, e) < 0.08);
                    if (nearbyEnemy.length > 0) {
                        // Sidestep away from detection
                        ty = f.y + (nearbyEnemy[0].y > f.y ? -0.1 : 0.1);
                    }
                }
                // NOT STEALTHED - aggressive assassination
                else if (enemyKing && m.rng.n() < 0.7) {
                    // Target enemy king for assassination
                    target = enemyKing;
                    tx = enemyKing.x;
                    ty = enemyKing.y;
                    f.aiState = 'Hunting King';
                } else {
                    f.aiState = 'Flanking';
                    ty = target.y + (f.y > target.y ? 0.15 : -0.15);
                }
                if (isWinning && !f.invisible) f.aiState = 'Assassinating';
            }
            // MAGES - STAY BACK, let tanks protect!
            else if (isRanged) {
                const safeZone = f.team === 0 ? 0.30 : 0.70; // Don't push past 30%
                const tooFar = f.team === 0 ? f.x > safeZone : f.x < safeZone;
                
                if (targetDist < 0.15 || tooFar) {
                    // Kite back to safety
                    f.aiState = 'Kiting';
                    tx = f.team === 0 ? Math.max(0.15, f.x - 0.05) : Math.min(0.85, f.x + 0.05);
                } else if (!hasLOS) {
                    f.aiState = 'Repositioning';
                    ty = f.y + (m.rng.n() - 0.5) * 0.15;
                    // Only move forward slightly for LOS, stay safe
                    tx = f.team === 0 ? Math.min(f.x + 0.02, safeZone) : Math.max(f.x - 0.02, safeZone);
                } else {
                    f.aiState = 'Casting';
                    // Hold position, don't push even when winning
                }
            }
            // HEALERS - STAY BACK, support from safety
            else if (isHealer) {
                const safeZone = f.team === 0 ? 0.25 : 0.75; // Stay at 25% of arena
                const tooFar = f.team === 0 ? f.x > 0.35 : f.x < 0.65;
                
                f.aiState = 'Supporting';
                if (targetDist < 0.12 || tooFar) {
                    // Retreat to safety
                    tx = safeZone;
                    f.aiState = 'Retreating';
                } else {
                    // Hold safe position
                    tx = f.team === 0 ? Math.min(f.x, 0.30) : Math.max(f.x, 0.70);
                }
            }
            // BARDS - backline drummers
            else if (isBard) {
                const safeX = f.team === 0 ? 0.18 : 0.82;
                if ((f.team === 0 && f.x > 0.35) || (f.team === 1 && f.x < 0.65)) {
                    tx = safeX; // Stay in backline
                    f.aiState = 'ü•Å Drumming';
                } else {
                    f.aiState = 'üéµ Playing';
                }
                // Kite if enemy gets too close
                if (targetDist < 0.12) {
                    tx = f.team === 0 ? f.x - 0.05 : f.x + 0.05;
                    f.aiState = 'Retreating';
                }
            }
            // NECROMANCERS - stay near corpses, mid-backline
            else if (isNecro) {
                const allDead = getAllFighters(m).filter(x => !x.alive);
                if (allDead.length > 0) {
                    // Move toward nearest corpse to raise
                    const nearestCorpse = allDead.reduce((best, c) => dist(f, c) < dist(f, best) ? c : best);
                    if (dist(f, nearestCorpse) > 0.25) {
                        tx = nearestCorpse.x;
                        ty = nearestCorpse.y;
                        f.aiState = 'Approaching Corpse';
                    } else {
                        f.aiState = 'üíÄ Channeling';
                    }
                } else {
                    // No corpses - stay in mid-backline
                    const safeX = f.team === 0 ? 0.25 : 0.75;
                    tx = safeX;
                    f.aiState = 'üíÄ Channeling';
                }
                // Kite if enemy gets too close
                if (targetDist < 0.1) {
                    tx = f.team === 0 ? f.x - 0.04 : f.x + 0.04;
                    f.aiState = 'Retreating';
                }
            }
            // BERSERKERS - always aggressive
            else {
                f.aiState = isReckless ? 'Raging' : 'Fighting';
                if (isWinning) f.aiState = 'Bloodlust';
            }
            
            // RALLY CRIES (Tanks & Kings only, 20 tick cooldown)
            if ((isTank || f.king) && f.rallyCd <= 0) {
                const teamMorale = m.teams[f.team].morale;
                const allyNear = allies.filter(a => a !== f && dist(f, a) < 0.25).length;
                
                // "TO ME!" - when pushing forward and morale is good
                if (teamMorale > 60 && isWinning && allyNear < 4 && m.rng.n() < 0.15) {
                    f.rallyCd = 20;
                    log(`üì£ ${fname(f)} bellows: "TO ME! CHARGE!"`, 'rally');
                    showDmg(f.x, f.y, 'üì£ TO ME!', 'buff');
                    // Rally nearby allies toward this fighter
                    allies.filter(a => a !== f && dist(f, a) < 0.35).forEach(a => {
                        a.rallyTarget = {x: f.x, y: f.y};
                        a.rallyBonus = 8; // 8 ticks of rally bonus
                        a.buffs.push({name:'Rallied', icon:'üì£', duration:8, atkBonus:4, spdBonus:0.1});
                    });
                }
                // "RETREAT AND REGROUP!" - when losing or low morale
                else if ((teamMorale < 50 || isLosing) && allyNear >= 2 && m.rng.n() < 0.1) {
                    f.rallyCd = 25;
                    log(`üì¢ ${fname(f)} commands: "RETREAT AND REGROUP!"`, 'rally');
                    showDmg(f.x, f.y, 'üì¢ REGROUP!', 'buff');
                    // Rally allies to fall back
                    const safeX = f.team === 0 ? 0.25 : 0.75;
                    allies.filter(a => a !== f && dist(f, a) < 0.4).forEach(a => {
                        a.rallyTarget = {x: safeX, y: 0.5};
                        a.rallyBonus = 10;
                        a.buffs.push({name:'Regrouping', icon:'üì¢', duration:10, defBonus:5});
                    });
                }
            }
            if (f.rallyCd > 0) f.rallyCd--;
            
            // SQUAD TACTICS - 3 groups with different objectives
            const squad = f.squad || 'guard';
            const teamKing = allies.find(a => a.king);
            const squadMates = allies.filter(a => a.squad === squad && a !== f && a.alive);
            const squadCentroid = squadMates.length > 0 ? {
                x: squadMates.reduce((s, a) => s + a.x, 0) / squadMates.length,
                y: squadMates.reduce((s, a) => s + a.y, 0) / squadMates.length
            } : centroid;
            
            if (squad === 'vanguard' && !f.king) {
                // VANGUARD: Push forward aggressively, engage closest enemies
                const pushLine = f.team === 0 ? 0.55 : 0.45;
                if ((f.team === 0 && f.x < pushLine) || (f.team === 1 && f.x > pushLine)) {
                    tx = tx * 0.7 + pushLine * 0.3;
                    f.aiState = 'Vanguard Push';
                }
                // Stay with squad
                if (squadMates.length > 0) {
                    ty = ty * 0.6 + squadCentroid.y * 0.4;
                }
            } else if (squad === 'flanker' && !f.king) {
                // FLANKERS: Circle around to top/bottom, hit backline
                const flankY = f.y < 0.5 ? 0.15 : 0.85; // Commit to a lane
                const pushX = f.team === 0 ? 0.6 : 0.4; // Get behind enemy
                // Priority: enemy mages/clerics
                const backline = enemies.filter(e => e.role === 'Mage' || e.role === 'Cleric' || e.role === 'Bard');
                if (backline.length > 0 && !f.invisible) {
                    const backTarget = backline.reduce((best, e) => dist(f, e) < dist(f, best) ? e : best);
                    tx = tx * 0.5 + backTarget.x * 0.5;
                    ty = ty * 0.4 + flankY * 0.6;
                    f.aiState = 'Flanking';
                } else {
                    // Circle around via edge
                    ty = ty * 0.5 + flankY * 0.5;
                    tx = tx * 0.7 + pushX * 0.3;
                    f.aiState = 'Circling';
                }
            } else if (squad === 'guard') {
                // GUARD: Stay near king, protect backline
                if (teamKing && teamKing.alive) {
                    const guardDist = dist(f, teamKing);
                    if (guardDist > 0.2) {
                        // Too far from king - close the gap
                        tx = tx * 0.5 + teamKing.x * 0.5;
                        ty = ty * 0.5 + teamKing.y * 0.5;
                        f.aiState = 'Guarding King';
                    }
                }
            }
            
            // GROUPING: Don't stray too far from SQUAD (instead of whole team)
            const squadSpread = squadMates.length > 0 ? 
                squadMates.reduce((max, a) => Math.max(max, dist(f, a)), 0) : 0;
            if (squadSpread > 0.25 && !f.king && f.role !== 'Rogue') {
                // Drift toward squad centroid
                tx = tx * 0.7 + squadCentroid.x * 0.3;
                ty = ty * 0.7 + squadCentroid.y * 0.3;
                if (f.aiState === 'Idle') f.aiState = 'Regrouping';
            }
            
            // COORDINATED PUSH: When morale is high, push together
            if (m.teams[f.team].morale > 80 && isWinning && !f.king) {
                const pushDir = f.team === 0 ? 0.03 : -0.03;
                tx += pushDir;
                if (f.aiState !== 'Peeling') f.aiState = 'Pushing';
            }
            
            // ANTI-HIDING: Force forward if stuck too far back
            const tooFarBack = f.team === 0 ? (f.x < 0.2) : (f.x > 0.8);
            if (tooFarBack) {
                f.idleTime++;
                if (f.idleTime > 2) {
                    tx = 0.5;
                    ty = 0.5 + (m.rng.n() - 0.5) * 0.3;
                    f.aiState = 'Pushing Forward';
                }
            } else {
                f.idleTime = Math.max(0, f.idleTime - 1);
            }
            
            // Speed affected by personality, buffs, and battle flow
            const spdBonus = f.buffs.reduce((sum, b) => sum + (b.spdBonus || 0), 0);
            let spdMult = isAggressive ? 1.15 : (isDefensive ? 0.9 : 1.0);
            spdMult *= aggression;
            if (f.rallyBonus) spdMult *= 1.1;
            const spd = (f.spd + spdBonus) * 0.012 * (m.teams[f.team].morale / 100) * spdMult;
            
            const dx = tx - f.x, dy = ty - f.y;
            const d = Math.hypot(dx, dy);
            if (d > 0.01) {
                let nx = f.x + (dx/d) * spd;
                let ny = f.y + (dy/d) * spd;
                
                // Collision with walls/pillars
                if (!blocked(nx, ny)) {
                    f.x = Math.max(0.03, Math.min(0.97, nx));
                    f.y = Math.max(0.05, Math.min(0.95, ny));
                }
            }
        }
    });
    
    // Process buffs, cooldowns, and mana regen
    all.forEach(f => {
        if (f.buffCd > 0) f.buffCd--;
        if (f.healCd > 0) f.healCd--;
        if (f.buffCdSelf > 0) f.buffCdSelf--;
        if (f.spellCd > 0) f.spellCd--;
        if (f.specialCd > 0) f.specialCd--;
        if (f.atkCd > 0) f.atkCd--;
        // Mana regen for casters
        if (f.maxMana > 0 && f.mana < f.maxMana) {
            f.mana = Math.min(f.maxMana, f.mana + 5); // +5 mana per tick
        }
        f.buffs = f.buffs.filter(b => {
            b.duration--;
            // Handle invisibility expiring
            if (b.special === 'invisible' && b.duration <= 0) {
                f.invisible = false;
                f.invisTicks = 0;
                // Set cooldown even if stealth expired without attacking
                if (f.role === 'Rogue' && f.stealthCooldown < 30) {
                    f.stealthCooldown = 30;
                }
                log(`üë§ ${fname(f)} emerges from the shadows!`, 'buff');
            }
            return b.duration > 0;
        });
        // Also decrement invisTicks directly
        if (f.invisTicks > 0) {
            f.invisTicks--;
            if (f.invisTicks <= 0 && f.invisible) {
                f.invisible = false;
                // Stealth expired without attacking - still needs cooldown!
                if (f.role === 'Rogue') {
                    f.stealthCooldown = 30; // 20 sec cooldown even if wasted
                }
            }
        }
    });
    
    // King morale effect
    m.teams.forEach(t => {
        if (t.kingAlive && t.morale < 100) t.morale = Math.min(100, t.morale + 0.3);
        if (!t.kingAlive && t.morale > 10) t.morale = Math.max(10, t.morale - 0.15);
    });
    
    // Victory check - 2-team battle
    const a0 = m.teams[0].f.filter(f=>f.alive).length;
    const a1 = m.teams[1].f.filter(f=>f.alive).length;
    if (a0 === 0 || a1 === 0 || m.teams[0].morale <= 0 || m.teams[1].morale <= 0) {
        m.status = 'ended';
        m.winner = (a0 > 0 && m.teams[0].morale > 0) ? 0 : 1;
        showVictoryCelebration(m.winner);
        setTimeout(showResult, 4000); // 4 seconds to read log and watch celebration
    }
    
    // Update momentum bar - tug of war style
    const m0 = m.teams[0].morale;
    const m1 = m.teams[1].morale;
    const total = m0 + m1 || 1;
    const allyShare = (m0 / total) * 100;
    const enemyShare = (m1 / total) * 100;
    const momentum = m0 - m1; // positive = ally winning
    
    // Show team names instead of percentages
    const team0Name = m.teamNames?.[0] || 'Allies';
    const team1Name = m.teamNames?.[1] || 'Enemy';
    document.getElementById('m0').textContent = team0Name;
    document.getElementById('m1').textContent = team1Name;
    document.getElementById('m0bar').style.width = allyShare + '%';
    document.getElementById('m1bar').style.width = enemyShare + '%';
    document.getElementById('m1bar').style.left = allyShare + '%';
    document.getElementById('momentum-needle').style.left = allyShare + '%';
    
    // Momentum state text and chevrons
    const stateEl = document.getElementById('momentum-state');
    const chevL = document.getElementById('chevrons-left');
    const chevR = document.getElementById('chevrons-right');
    
    if (momentum > 40) {
        stateEl.textContent = 'CRUSHING!';
        stateEl.style.color = '#32CD32';
        chevL.style.display = 'block'; chevR.style.display = 'none';
    } else if (momentum > 20) {
        stateEl.textContent = 'PUSHING';
        stateEl.style.color = '#7CFC00';
        chevL.style.display = 'block'; chevR.style.display = 'none';
    } else if (momentum > 5) {
        stateEl.textContent = 'ADVANTAGE';
        stateEl.style.color = '#90EE90';
        chevL.style.display = 'none'; chevR.style.display = 'none';
    } else if (momentum < -40) {
        stateEl.textContent = 'ROUTED!';
        stateEl.style.color = '#DC143C';
        chevL.style.display = 'none'; chevR.style.display = 'block';
    } else if (momentum < -20) {
        stateEl.textContent = 'FALLING';
        stateEl.style.color = '#FF6347';
        chevL.style.display = 'none'; chevR.style.display = 'block';
    } else if (momentum < -5) {
        stateEl.textContent = 'LOSING';
        stateEl.style.color = '#FFA07A';
        chevL.style.display = 'none'; chevR.style.display = 'none';
    } else {
        stateEl.textContent = 'EVEN';
        stateEl.style.color = '#FFD700';
        chevL.style.display = 'none'; chevR.style.display = 'none';
    }
}

function dist(a, b) { return Math.hypot(a.x - b.x, a.y - b.y); }

function blocked(x, y) {
    // Check walls (solid, impassable)
    const walls = state.match?.walls || [];
    for (const w of walls) {
        if (x > w.x - w.w/2 - 0.015 && x < w.x + w.w/2 + 0.015 &&
            y > w.y - w.h/2 - 0.015 && y < w.y + w.h/2 + 0.015) return true;
    }
    return false;
}

function checkLOS(x1, y1, x2, y2) {
    // Simple raycast
    const steps = 10;
    for (let i = 1; i < steps; i++) {
        const t = i / steps;
        const x = x1 + (x2 - x1) * t;
        const y = y1 + (y2 - y1) * t;
        if (blocked(x, y)) return false;
    }
    return true;
}

// Cache fighter element references to avoid DOM queries every frame
const fighterCache = new Map();

// AI state icons
const stateIcons = {
    'Attacking':'‚öîÔ∏è', 'Casting':'üîÆ', 'Charging':'üèÉ', 'Blocking':'üõ°Ô∏è',
    'Healing':'üíö', 'Buffing':'‚ú®', 'Flanking':'üî™', 'Kiting':'üèπ',
    'Defending':'üõ°Ô∏è', 'Rallying':'üì£', 'Fleeing':'üò±', 'Peeling':'ü§ù',
    'Hunting King':'üëë', 'Leading Charge':'‚öîÔ∏è', 'Assassinating':'üíÄ',
    'Raging':'üî•', 'Bloodlust':'ü©∏', 'Out of Mana':'üíß', 'No Line of Sight':'‚ùå',
    'Channeling':'üîÑ', 'ü•Å Drumming':'ü•Å', 'üéµ Playing':'üéµ', 'Inspiring':'üéµ', 'Mocking':'üó£Ô∏è',
    'üíÄ Channeling':'üíÄ', 'Summoning':'üíÄ', 'Raising Dead':'üßü', 'Reanimated':'üßü', 'Summoned':'üíÄ',
    'üë§ Stalking':'üë§'
};

function render() {
    const m = state.match;
    if (!m) return;
    const arena = getArena();
    
    getAllFighters(m).forEach(f => {
        let cache = fighterCache.get(f.uid);
        
        if (!cache) {
            // Create element and cache all child references
            const el = document.createElement('div');
            el.id = `f-${f.uid}`;
            el.className = `fighter team${f.team}${f.king ? ' king' : ''}`;
            el.onclick = () => inspect(f.uid);
            const hasMana = f.maxMana > 0;
            const isTank = f.role === 'Tank';
            el.innerHTML = `
                ${f.king ? `<div class="fighter-crown">${f.rankIcon || 'üéñÔ∏è'}</div>` : ''}
                <div class="fighter-state"></div>
                ${isTank ? '<div class="fighter-shield"></div>' : ''}
                <div class="fighter-hp"><div class="fighter-hp-fill"></div></div>
                ${hasMana ? '<div class="fighter-mana"><div class="fighter-mana-fill"></div></div>' : ''}
                <div class="fighter-body"><img src="${getSpriteUrl(f)}" style="image-rendering:pixelated"></div>
            `;
            arena.appendChild(el);
            
            // Cache all refs once - never query again!
            cache = {
                el: el,
                hpFill: el.querySelector('.fighter-hp-fill'),
                manaFill: el.querySelector('.fighter-mana-fill'),
                shield: el.querySelector('.fighter-shield'),
                state: el.querySelector('.fighter-state'),
                lastX: -1, lastY: -1, lastPct: -1, lastState: ''
            };
            fighterCache.set(f.uid, cache);
        }
        
        const { el, hpFill, manaFill, shield, state: stateEl } = cache;
        
        // Only update position if changed (avoid unnecessary style writes)
        // Use transform for GPU-accelerated positioning (no layout thrashing)
        const px = Math.round(f.x * 1000) / 10;
        const py = Math.round(f.y * 1000) / 10;
        if (cache.lastX !== px || cache.lastY !== py) {
            const tx = (f.x * arenaRect.width) - (f.king ? 22 : 16); // center offset
            const ty = (f.y * arenaRect.height) - (f.king ? 22 : 16);
            el.style.transform = `translate(${tx}px, ${ty}px)`;
            cache.lastX = px;
            cache.lastY = py;
        }
        
        // HP bar - only update if changed
        const pct = Math.max(0, Math.round(f.hp / f.maxHp * 100));
        if (cache.lastPct !== pct) {
            hpFill.style.width = pct + '%';
            hpFill.style.background = pct > 50 ? '#32CD32' : pct > 25 ? '#FFD700' : '#DC143C';
            cache.lastPct = pct;
        }
        
        // Class toggles - ONLY if state changed (avoid reflows)
        const shouldBeDead = !f.alive;
        const shouldBeInvis = f.invisible && f.alive;
        if (cache.wasDead !== shouldBeDead) {
            el.classList.toggle('dead', shouldBeDead);
            cache.wasDead = shouldBeDead;
        }
        if (cache.wasInvis !== shouldBeInvis) {
            el.classList.toggle('invisible', shouldBeInvis);
            cache.wasInvis = shouldBeInvis;
        }
        
        // Selection marker - track inspected fighter
        const isInspected = state.inspected === f.uid;
        if (cache.wasInspected !== isInspected) {
            el.classList.toggle('inspected', isInspected);
            cache.wasInspected = isInspected;
        }
        
        // Mana bar - only if changed
        if (manaFill && f.maxMana > 0) {
            const manaPct = Math.round(f.mana / f.maxMana * 100);
            if (cache.lastMana !== manaPct) {
                manaFill.style.width = manaPct + '%';
                cache.lastMana = manaPct;
            }
        }
        
        // Shield direction - only if changed significantly
        if (shield && f.role === 'Tank' && f.alive) {
            const deg = Math.round(f.shieldDir * 180 / Math.PI);
            if (cache.lastShieldDeg !== deg) {
                shield.style.transform = `translate(-50%, -50%) rotate(${deg}deg)`;
                cache.lastShieldDeg = deg;
            }
            shield.style.display = 'block';
        } else if (shield) {
            shield.style.display = 'none';
        }
        
        // Show BUFF ICONS instead of AI state (more useful visual)
        const buffIcons = f.buffs.map(b => b.icon).join('');
        const displayIcon = buffIcons || (f.invisible ? 'üë§' : '');
        if (cache.lastState !== displayIcon) {
            if (displayIcon && f.alive) {
                stateEl.textContent = displayIcon;
                stateEl.style.display = 'block';
            } else {
                stateEl.style.display = 'none';
            }
            cache.lastState = displayIcon;
        }
    });
    
    // ==========================================
    // RENDER ITEMS - powerups on the field (only create once, don't reposition)
    // ==========================================
    if (m.items) {
        m.items.forEach(item => {
            if (!item.rendered) {
                // Create item element ONCE
                const el = document.createElement('div');
                el.id = item.id;
                el.className = `item item-${item.type}`;
                el.innerHTML = `<div class="item-icon">${item.icon}</div>`;
                el.title = item.name;
                // Position once at creation
                const tx = item.x * arenaRect.width - 14;
                const ty = item.y * arenaRect.height - 14;
                el.style.left = tx + 'px';
                el.style.top = ty + 'px';
                arena.appendChild(el);
                item.rendered = true;
            }
        });
    }
    
    updateInsp();
}

// OBJECT POOLS for performance - reuse DOM elements
const dmgPool = [];
const particlePool = [];
const MAX_POOL = 30;
const MAX_PARTICLES = 15; // Max active particles at once
let activeParticles = 0;
let arenaEl = null; // Cached arena reference
let arenaRect = { width: 0, height: 0 }; // Cached dimensions
let lastDmgTime = 0;
const DMG_THROTTLE = 50; // Min ms between damage numbers

function getArena() {
    if (!arenaEl) arenaEl = document.getElementById('arena');
    return arenaEl;
}

function updateArenaRect() {
    const arena = getArena();
    if (arena) {
        const rect = arena.getBoundingClientRect();
        arenaRect.width = rect.width;
        arenaRect.height = rect.height;
    }
}

// Update arena dimensions on resize
window.addEventListener('resize', updateArenaRect);

// Death markers - skull + blood pool left on arena
function spawnDeathMarker(x, y) {
    const marker = document.createElement('div');
    marker.className = 'death-marker';
    marker.innerHTML = `<div class="skull">üíÄ</div><div class="blood"></div>`;
    marker.style.left = x * 100 + '%';
    marker.style.top = y * 100 + '%';
    getArena().appendChild(marker);
    // Markers persist until battle ends (cleared with arena.innerHTML = '')
}

function showDmg(x, y, val, type) {
    // Only show important damage numbers for performance
    if (type !== 'lethal' && type !== 'backstab' && type !== 'crit' && type !== 'king' && type !== 'buff') {
        return; // Skip regular damage numbers
    }
    
    let el = dmgPool.pop();
    if (!el) {
        el = document.createElement('div');
    }
    el.className = `damage-num ${type}`;
    el.textContent = typeof val === 'string' ? val : `-${val}`;
    el.style.left = x * 100 + '%';
    el.style.top = y * 100 + '%';
    getArena().appendChild(el);
    
    setTimeout(() => {
        el.remove();
        if (dmgPool.length < MAX_POOL) dmgPool.push(el);
    }, 600);
}

function spawnParticles(x, y, type, count) {
    // Disabled for performance
}

// HIT MARKERS - simple emoji pops
function showHit(x, y, isCrit) {
    const el = document.createElement('div');
    el.className = 'hit-marker';
    el.textContent = isCrit ? 'üí•' : '‚öîÔ∏è';
    el.style.left = x * 100 + '%';
    el.style.top = y * 100 + '%';
    getArena().appendChild(el);
    setTimeout(() => el.remove(), 400);
}

// SPELL EFFECTS - colored circles
function showSpell(x, y, spellType) {
    const el = document.createElement('div');
    el.className = `spell-cast ${spellType}`;
    el.style.left = x * 100 + '%';
    el.style.top = y * 100 + '%';
    getArena().appendChild(el);
    setTimeout(() => el.remove(), 500);
}

function screenShake(intensity) {
    const arena = document.querySelector('.arena-screen');
    if (!arena) return;
    
    // Only do big shakes for dramatic moments (performance friendly)
    if (intensity === 'big') {
        arena.classList.remove('shake', 'bigShake');
        void arena.offsetWidth; // Trigger reflow
        arena.classList.add('bigShake');
        setTimeout(() => arena.classList.remove('bigShake'), 500);
    } else if (intensity === 'normal') {
        arena.classList.remove('shake', 'bigShake');
        void arena.offsetWidth;
        arena.classList.add('shake');
        setTimeout(() => arena.classList.remove('shake'), 300);
    }
    // 'small' shakes disabled for performance
}

function flashFighter(uid, type) {
    // Disabled for performance
}

function showAtk(from, to, color) {
    // Disabled for performance
}

// Global: Track used battle names to ensure uniqueness
const usedBattleNames = [];

function log(txt, type='') {
    const c = document.getElementById('log-content');
    const e = document.createElement('div');
    e.className = `log-entry ${type}`;
    e.textContent = txt;
    c.appendChild(e);
    c.scrollTop = c.scrollHeight;
    // Keep only last 100 entries
    while (c.children.length > 100) c.removeChild(c.firstChild);
    
    // Store key events in battleLog for story generation
    if (state.match && state.match.battleLog) {
        const keyTypes = ['kill', 'king', 'crit', 'rally', 'magic', 'rout', 'riposte'];
        if (keyTypes.includes(type) || txt.includes('CRITICAL') || txt.includes('resurrect') || txt.includes('morale') || txt.includes('rallies')) {
            state.match.battleLog.push({ txt, type, tick: state.match?.tick || 0 });
        }
    }
}

// Get fighter display name with King prefix if applicable
function fname(f) {
    if (f.king && f.rank) return `${f.rank} ${f.name}`;
    return f.name;
}

// BATTLE CRIES - King commands that appear on battlefield
const KING_CRIES = {
    charge: ['"TO ME! CHARGE!"', '"FORWARD, FOR GLORY!"', '"CRUSH THEM ALL!"', '"NO MERCY!"', '"ATTACK!"'],
    command: ['"HOLD YOUR POSITIONS!"', '"STAY BEHIND ME!"', '"I COMMAND FROM HERE!"', '"RAIN DESTRUCTION!"'],
    support: ['"STAY STRONG!"', '"I WILL PROTECT YOU!"', '"HAVE FAITH!"', '"THE LIGHT GUIDES US!"', '"STAND TOGETHER!"'],
    assassin: ['"FROM THE SHADOWS..."', '"THEIR KING DIES FIRST..."', '"STRIKE UNSEEN!"', '"THE THRONE IS MINE!"'],
    rally: ['"RALLY TO ME!"', '"WE STAND TOGETHER!"', '"HOLD THE LINE!"', '"DO NOT FALTER!"'],
    lastStand: ['"TO THE DEATH!"', '"I WILL NOT YIELD!"', '"THEY SHALL NOT PASS!"', '"FOR MY PEOPLE!"'],
    taunt: ['"IS THAT ALL YOU HAVE?"', '"YOUR KING IS WEAK!"', '"KNEEL BEFORE ME!"', '"PATHETIC!"']
};

function battleCry(f, cryType, customText) {
    if (!f || !state.match) return;
    
    // Don't spam cries - cooldown per fighter
    if (f.lastCryTick && state.match.tick - f.lastCryTick < 150) return;
    f.lastCryTick = state.match.tick;
    
    // Pick cry text
    const cries = KING_CRIES[cryType] || KING_CRIES.rally;
    const cry = customText || cries[Math.floor(Math.random() * cries.length)];
    
    // Log it
    log(`üëë ${fname(f)} commands: ${cry}`, 'king');
    
    // Show floating text on battlefield
    const arena = getArena();
    if (!arena) return;
    
    const el = document.createElement('div');
    el.className = `battle-cry ${cryType === 'command' ? 'command' : cryType === 'support' ? 'support' : cryType === 'assassin' ? 'threat' : 'rally'}`;
    el.textContent = cry;
    
    // Position over the fighter
    const px = f.x * arenaRect.width;
    const py = f.y * arenaRect.height - 30;
    el.style.left = px + 'px';
    el.style.top = py + 'px';
    
    arena.appendChild(el);
    
    // Remove after animation
    setTimeout(() => el.remove(), 2500);
}

// DWARF FORTRESS-STYLE COMBAT LOG GENERATOR
const DF = {
    parts: ['head', 'cranium', 'upper body', 'lower body', 'right arm', 'left arm', 'right leg', 'left leg', 'neck', 'spine', 'gut', 'shoulder', 'ribs', 'thigh', 'hand', 'foot'],
    partsByRole: {
        Rogue: ['neck', 'spine', 'ribs', 'back'], // Assassins target vitals
        Tank: ['left leg', 'right leg', 'lower body'], // Tanks go low
    },
    verbs: {
        Tank: ['slashes', 'cleaves', 'hacks', 'batters', 'smashes', 'chops'],
        Berserker: ['rends', 'tears into', 'savages', 'brutalizes', 'mauls', 'gores'],
        Rogue: ['stabs', 'slices', 'shanks', 'punctures', 'gashes', 'backstabs'],
        Mage: ['blasts', 'scorches', 'sears', 'incinerates', 'freezes', 'chars'],
        Cleric: ['smites', 'strikes', 'bashes', 'hammers', 'crushes', 'consecrates']
    },
    weapons: {
        Tank: ['longsword', 'battle axe', 'warhammer'],
        Berserker: ['jagged axe', 'serrated blade', 'brutal mace'],
        Rogue: ['poisoned dagger', 'curved blade', 'throwing knife'],
        Mage: ['arcane bolt', 'fire blast', 'frost shard'],
        Cleric: ['holy mace', 'blessed hammer', 'sacred staff']
    },
    blowQuality: [
        {name: 'grazing blow', weight: 0.1},
        {name: 'glancing blow', weight: 0.25},
        {name: 'solid blow', weight: 0.35},
        {name: 'heavy blow', weight: 0.2},
        {name: 'crushing blow', weight: 0.08},
        {name: 'perfect strike', weight: 0.02}
    ],
    wounds: ['bruises', 'batters heavily', 'fractures', 'shatters', 'tears open', 'mangles', 'pulps'],
    effects: [
        'A spurt of blood flies!',
        'Sparks fly, glancing off armor!',
        'Bone crunches sickeningly!',
        'The flesh tears, exposing muscle!',
        'Blood sprays across the ground!',
        'The limb hangs limp!',
        ''
    ],
    counters: ['ripostes with a quick slash', 'parries and counters', 'deflects and strikes back', 'sidesteps and retaliates', 'kicks away and swings back', 'catches the blade and punches'],
    critFlavor: ['VITAL HIT!', 'CRITICAL STRIKE!', 'DEVASTATING BLOW!', 'BONE-SHATTERING HIT!', 'FATAL WOUND!']
};

function weightedPick(arr, rng) {
    if (arr[0].weight) {
        const total = arr.reduce((s, x) => s + x.weight, 0);
        let r = rng.n() * total;
        for (const item of arr) {
            r -= item.weight;
            if (r <= 0) return item.name;
        }
        return arr[arr.length-1].name;
    }
    return arr[Math.floor(rng.n() * arr.length)];
}

function combatLog(attacker, defender, dmg, isCrit, isBlocked, isRiposte) {
    const rng = state.match.rng;
    
    // Pick body part (role-specific preference or random)
    const roleParts = DF.partsByRole[attacker.role];
    const partPool = (roleParts && rng.n() < 0.4) ? roleParts : DF.parts;
    const part = partPool[Math.floor(rng.n() * partPool.length)];
    
    // Pick verb and weapon
    const verbs = DF.verbs[attacker.role] || DF.verbs.Tank;
    const verb = verbs[Math.floor(rng.n() * verbs.length)];
    const weapons = DF.weapons[attacker.role] || DF.weapons.Tank;
    const weapon = weapons[Math.floor(rng.n() * weapons.length)];
    
    // Blow quality (weighted)
    const quality = weightedPick(DF.blowQuality, rng);
    
    // Wound severity based on damage
    const severity = Math.min(6, Math.floor(dmg / 7));
    const wound = DF.wounds[severity] || 'bruises';
    
    // Extra effect (more likely on high damage)
    const effectChance = dmg > 25 ? 0.7 : (dmg > 15 ? 0.4 : 0.15);
    const effect = rng.n() < effectChance ? DF.effects[Math.floor(rng.n() * (DF.effects.length-1))] : '';
    
    // BLOCKED
    if (isBlocked) {
        const blockFlavor = ['deflects off the shield', 'glances harmlessly away', 'is caught by the shield', 'clangs against raised steel'][Math.floor(rng.n()*4)];
        log(`üõ°Ô∏è ${fname(attacker)}'s ${weapon} ${blockFlavor}! ${fname(defender)} holds firm. [${dmg}]`, 'block');
        return;
    }
    
    // RIPOSTE
    if (isRiposte) {
        const counter = DF.counters[Math.floor(rng.n() * DF.counters.length)];
        log(`‚öîÔ∏è ${fname(defender)} ${counter}!`, 'riposte');
    }
    
    // MAIN STRIKE
    if (isCrit) {
        const critFlav = DF.critFlavor[Math.floor(rng.n() * DF.critFlavor.length)];
        log(`üí• ${fname(attacker)} ${verb} ${fname(defender)}'s ${part} with ${weapon}‚Äî${critFlav} The ${part} ${wound}! ${effect} [${dmg}]`, 'crit');
    } else if (dmg > 18) {
        log(`‚öîÔ∏è ${fname(attacker)} ${verb} ${fname(defender)} in the ${part}, ${quality}! The ${part} ${wound}. ${effect} [${dmg}]`, 'wound');
    } else if (dmg > 8) {
        log(`${fname(attacker)} ${verb} ${fname(defender)}'s ${part}, ${quality}. [${dmg}]`, 'strike');
    }
    // Light hits (<8 dmg) don't log to reduce spam
}

function inspect(uid) {
    state.inspected = uid;
    updateInsp();
    // Slide open the panel and set team border color
    const panel = document.getElementById('insp-panel');
    panel.classList.add('open');
    // Set border color based on team
    const f = getAllFighters(state.match).find(x=>x.uid===uid);
    if (f) {
        panel.style.borderColor = f.team === 0 ? '#32CD32' : '#DC143C';
    }
}

function closeInspector() {
    document.getElementById('insp-panel').classList.remove('open');
    state.inspected = null;
}

function updateInsp() {
    if (!state.inspected || !state.match) return;
    const f = getAllFighters(state.match).find(x=>x.uid===state.inspected);
    if (!f) return;
    const pct = Math.max(0, f.hp / f.maxHp * 100);
    const col = pct > 50 ? '#32CD32' : pct > 25 ? '#FFD700' : '#DC143C';
    
    // Calculate effective stats with buffs
    const atkBonus = f.buffs.reduce((sum, b) => sum + (b.atkBonus || 0), 0);
    const defBonus = f.buffs.reduce((sum, b) => sum + (b.defBonus || 0), 0);
    const spdBonus = f.buffs.reduce((sum, b) => sum + (b.spdBonus || 0), 0);
    
    const buffsHtml = f.buffs.length ? 
        `<div style="margin:8px 0;padding:6px;background:#1a1a0a;border:1px solid #FFD700;">
            <div style="font-size:8px;color:#FFD700;margin-bottom:4px;">ACTIVE BUFFS</div>
            ${f.buffs.map(b => `<span style="margin-right:5px;" title="${b.name} (${b.duration} ticks)">${b.icon}</span>`).join('')}
        </div>` : '';
    
    const gear = f.gear || GEAR[f.role] || {};
    
    // Get current target info
    const targetFighter = f.currentTarget ? getAllFighters(state.match).find(x => x.uid === f.currentTarget) : null;
    
    // AI state colors
    const aiColors = {
        'Attacking':'#DC143C', 'Casting':'#9932CC', 'Charging':'#FF4500', 'Blocking':'#4169E1',
        'Healing':'#32CD32', 'Buffing':'#00FFFF', 'Flanking':'#FF8C00', 'Kiting':'#FFD700',
        'Defending':'#4169E1', 'Supporting':'#32CD32', 'Retreating':'#888', 'Repositioning':'#888',
        'Advancing':'#FF8C00', 'Raging':'#FF0000', 'Assassinating':'#8B0000', 'Dead':'#444',
        'Channeling':'#9932CC', 'Cooldown':'#666', 'Fighting':'#DC143C', 'Positioning':'#888',
        'Leading Charge':'#FFD700', 'Rallying':'#FFD700', 'Last Stand':'#DC143C', 'Rallied':'#FFD700',
        'Hunting King':'#FF00FF', 'Bloodlust':'#8B0000', 'Pushing':'#FF8C00', 'Pushing Forward':'#FF8C00',
        'Fleeing':'#888800', 'Peeling':'#00CED1', 'Regrouping':'#9370DB', 'Idle':'#555',
        'Unsticking':'#FF69B4', 'Out of Mana':'#4169E1', 'No Line of Sight':'#666',
        'ü•Å Drumming':'#DAA520', 'üéµ Playing':'#DAA520', 'Inspiring':'#FFD700', 'Mocking':'#9932CC',
        'üíÄ Channeling':'#4B0082', 'Summoning':'#8B008B', 'Raising Dead':'#556B2F', 'Reanimated':'#556B2F', 'Summoned':'#4B0082'
    };
    const aiColor = aiColors[f.aiState] || '#888';
    
    document.getElementById('insp-content').innerHTML = `
        <div class="insp-portrait" id="insp-portrait-container"><img id="insp-pfp" src="${getSpriteUrl(f)}" style="image-rendering:pixelated"></div>
        <div class="insp-name">${f.king ? (f.rankIcon || 'üéñÔ∏è') + ' ' : ''}${f.name}</div>
        ${f.king && f.rank ? `<div style="text-align:center;color:#FFD700;font-size:10px;margin-bottom:5px;">${f.rank}</div>` : ''}
        <div class="insp-role">${f.role} ‚Ä¢ ${f.team===0?'ALLY':'ENEMY'}</div>
        
        <div style="margin:6px 0;padding:6px;background:#0a0a1a;border:2px solid ${aiColor};text-align:center;">
            <div style="font-size:7px;color:#888;">ü§ñ AI STATE</div>
            <div style="font-size:11px;color:${aiColor};font-weight:bold;">${f.aiState || 'Idle'}</div>
        </div>
        
        ${targetFighter ? `
        <div style="margin:6px 0;padding:6px;background:#1a0a0a;border:1px solid ${targetFighter.team === f.team ? '#32CD32' : '#DC143C'};display:flex;align-items:center;gap:8px;">
            <img id="insp-target-pfp" src="${getSpriteUrl(targetFighter)}" style="width:40px;height:40px;image-rendering:pixelated;border:2px solid ${targetFighter.team === f.team ? '#32CD32' : '#DC143C'};">
            <div style="flex:1;">
                <div style="font-size:7px;color:#888;">üéØ ${targetFighter.team === f.team ? 'SUPPORTING' : 'TARGETING'}</div>
                <div style="font-size:10px;color:#fff;font-weight:bold;">${targetFighter.name}</div>
                <div style="font-size:8px;color:${targetFighter.team === f.team ? '#32CD32' : '#DC143C'};">${targetFighter.role} ‚Ä¢ ${Math.max(0, targetFighter.hp)}/${targetFighter.maxHp} HP</div>
            </div>
        </div>` : ''}
        
        <div style="display:flex;gap:8px;margin-bottom:8px;font-size:8px;">
            <div style="flex:1;padding:4px;background:#111;border:1px solid #333;text-align:center;">
                <div style="color:#888;">üé≠ Trait</div>
                <div style="color:#FFD700;">${f.trait || '‚Äî'}</div>
            </div>
            <div style="flex:1;padding:4px;background:#111;border:1px solid #333;text-align:center;">
                <div style="color:#888;">üß† Personality</div>
                <div style="color:#FF8C00;">${f.personality || '‚Äî'}</div>
            </div>
        </div>
        
        ${f.routed ? `
        <div style="margin-bottom:8px;padding:6px;background:#2a2a00;border:2px solid #888800;text-align:center;">
            <div style="font-size:9px;color:#888800;">üò± ROUTED!</div>
            <div style="font-size:11px;color:#FFFF00;">Fleeing (${f.routedTicks} ticks)</div>
        </div>` : ''}
        
        ${f.rallyBonus > 0 ? `
        <div style="margin-bottom:8px;padding:6px;background:#2a2a0a;border:2px solid #FFD700;text-align:center;">
            <div style="font-size:9px;color:#FFD700;">üëë KING'S RALLY AURA</div>
            <div style="font-size:11px;color:#32CD32;">+${Math.round(f.rallyBonus*100)}% ATK/DEF</div>
        </div>` : ''}
        
        <div class="insp-hp"><div class="insp-hp-fill" style="width:${pct}%;background:${col}"></div><div class="insp-hp-text">${Math.max(0,f.hp)}/${f.maxHp}</div></div>
        
        ${buffsHtml}
        
        <div style="margin:8px 0;padding:6px;background:#111;border:1px solid #333;font-size:8px;">
            <div style="color:#888;margin-bottom:4px;">‚öôÔ∏è GEAR</div>
            <div style="color:#aaa;">${gear.weapon || '‚Äî'}</div>
            <div style="color:#aaa;">${gear.armor || '‚Äî'}</div>
            <div style="color:#aaa;">${gear.accessory || '‚Äî'}</div>
        </div>
        
        <div class="insp-stats">
            <div class="insp-stat">‚öî ATK<br><span class="insp-stat-val">${f.atk}${atkBonus ? `<span style="color:#0f0;font-size:9px;">+${atkBonus}</span>` : ''}</span></div>
            <div class="insp-stat">üõ° DEF<br><span class="insp-stat-val">${f.def}${defBonus ? `<span style="color:#0f0;font-size:9px;">+${defBonus}</span>` : ''}</span></div>
            <div class="insp-stat">üí® SPD<br><span class="insp-stat-val">${f.spd.toFixed(1)}${spdBonus ? `<span style="color:#0f0;font-size:9px;">+${spdBonus.toFixed(1)}</span>` : ''}</span></div>
            <div class="insp-stat">üíÄ KILLS<br><span class="insp-stat-val">${f.kills}</span></div>
        </div>
        
        <div style="margin-top:8px;padding:6px;background:#111;border:1px solid #333;font-size:8px;">
            <div style="color:#888;margin-bottom:4px;">üìä COMBAT STATS</div>
            <div style="display:flex;justify-content:space-between;"><span>Damage Done</span><span style="color:#DC143C;">${f.dmgDone}</span></div>
            <div style="display:flex;justify-content:space-between;"><span>Damage Taken</span><span style="color:#FF8C00;">${f.dmgTaken}</span></div>
            <div style="display:flex;justify-content:space-between;"><span>Healing Done</span><span style="color:#32CD32;">${f.healDone}</span></div>
        </div>
        
        ${(f.healCd > 0 || f.buffCdSelf > 0 || f.spellCd > 0) ? `
        <div style="margin-top:8px;padding:6px;background:#1a1a0a;border:1px solid #666;font-size:8px;">
            <div style="color:#666;margin-bottom:4px;">‚è±Ô∏è COOLDOWNS</div>
            ${f.healCd > 0 ? `<div style="display:flex;justify-content:space-between;"><span>Heal</span><span style="color:#32CD32;">${f.healCd}</span></div>` : ''}
            ${f.buffCdSelf > 0 ? `<div style="display:flex;justify-content:space-between;"><span>Buff</span><span style="color:#00FFFF;">${f.buffCdSelf}</span></div>` : ''}
            ${f.spellCd > 0 ? `<div style="display:flex;justify-content:space-between;"><span>Spell</span><span style="color:#9932CC;">${f.spellCd}</span></div>` : ''}
        </div>` : ''}
        
        ${getSpellbookHtml(f)}
    `;
    
    // Generate layered PFP asynchronously - use cache to prevent flickering
    const cacheKey = `${f.id}-${f.role}`;
    if (pfpCache.has(cacheKey)) {
        // Use cached PFP immediately
        const pfpImg = document.getElementById('insp-pfp');
        if (pfpImg) pfpImg.src = pfpCache.get(cacheKey);
    } else if (window.PFPGenerator && window.PFPGenerator.generateFighterPFP) {
        window.PFPGenerator.generateFighterPFP(f, { size: 100 }).then(dataUrl => {
            if (dataUrl) {
                pfpCache.set(cacheKey, dataUrl); // Cache it
                const pfpImg = document.getElementById('insp-pfp');
                if (pfpImg) pfpImg.src = dataUrl;
            }
        }).catch(e => console.warn('PFP generation failed:', e));
    }
}

// SPELLBOOK - abilities by role
const SPELLBOOKS = {
    Tank: [
        {name:'Shield Block', icon:'üõ°Ô∏è', desc:'Block incoming attacks, can riposte', type:'Passive'},
        {name:'Taunt', icon:'üò§', desc:'Force enemies to target you', type:'Active'},
        {name:'Rally Cry', icon:'üì£', desc:'"TO ME!" or "RETREAT!"', type:'Active', cd:20}
    ],
    Berserker: [
        {name:'Rage', icon:'üò°', desc:'+ATK when HP low', type:'Passive'},
        {name:'Bloodlust', icon:'ü©∏', desc:'Heal on kill', type:'Passive'},
        {name:'Reckless Swing', icon:'‚öîÔ∏è', desc:'Heavy damage, ignores some DEF', type:'Attack'}
    ],
    Mage: [
        {name:'Fireball', icon:'üî•', desc:'Ranged fire damage', type:'Spell', cost:25},
        {name:'Frost Bolt', icon:'‚ùÑÔ∏è', desc:'Ranged frost damage + slow', type:'Spell', cost:25},
        {name:'Lightning', icon:'‚ö°', desc:'Chain lightning damage', type:'Spell', cost:25}
    ],
    Cleric: [
        {name:'Heal', icon:'üíö', desc:'Restore ally HP', type:'Spell', cost:20},
        {name:'Blessing', icon:'‚ú®', desc:'Buff ally ATK', type:'Spell', cost:20},
        {name:'Shield', icon:'üõ°Ô∏è', desc:'Buff ally DEF', type:'Spell', cost:20},
        {name:'Smite', icon:'‚òÄÔ∏è', desc:'Holy damage to undead', type:'Attack'}
    ],
    Rogue: [
        {name:'Backstab', icon:'üî™', desc:'+Crit from behind', type:'Passive'},
        {name:'Evasion', icon:'üí®', desc:'Chance to dodge attacks', type:'Passive'},
        {name:'Assassinate', icon:'üíÄ', desc:'Execute low HP targets', type:'Attack'}
    ],
    Bard: [
        {name:'War Drums', icon:'ü•Å', desc:'+3 ATK aura to nearby allies', type:'Passive'},
        {name:'Bardic Inspiration', icon:'üéµ', desc:'Big buff to one ally', type:'Spell', cost:20},
        {name:'Vicious Mockery', icon:'üó£Ô∏è', desc:'Psychic damage + debuff', type:'Spell', cost:15},
        {name:'Song of Rest', icon:'üò¥', desc:'Heal allies over time', type:'Spell', cost:25}
    ],
    Necromancer: [
        {name:'Summon Skeleton', icon:'üíÄ', desc:'Summon skeleton on kill (max 3)', type:'Spell', cost:15},
        {name:'Raise Dead', icon:'üßü', desc:'Resurrect fallen fighter at 50% HP', type:'Spell', cost:40},
        {name:'Life Drain', icon:'üíú', desc:'Steal HP from enemy', type:'Attack'},
        {name:'Death Aura', icon:'‚ò†Ô∏è', desc:'Nearby enemies take damage over time', type:'Passive'}
    ],
    Minion: [
        {name:'Bone Claws', icon:'ü¶¥', desc:'Basic melee attack', type:'Attack'},
        {name:'Undead', icon:'üíÄ', desc:'Cannot be healed, immune to fear', type:'Passive'}
    ]
};

function getSpellbookHtml(f) {
    const spells = SPELLBOOKS[f.role] || [];
    if (!spells.length) return '';
    return `
        <div style="margin-top:8px;padding:6px;background:#0a0a1a;border:1px solid #9932CC;font-size:8px;">
            <div style="color:#9932CC;margin-bottom:6px;">üìñ SPELLBOOK</div>
            ${spells.map(s => `
                <div style="display:flex;align-items:center;gap:6px;margin-bottom:4px;padding:3px;background:#111;border-radius:3px;">
                    <span style="font-size:12px;">${s.icon}</span>
                    <div style="flex:1;">
                        <div style="color:#fff;font-size:8px;">${s.name}</div>
                        <div style="color:#666;font-size:7px;">${s.desc}</div>
                    </div>
                    <span style="color:${s.cost ? '#4169E1' : '#32CD32'};font-size:7px;">${s.cost ? s.cost+'üíß' : s.type}</span>
                </div>
            `).join('')}
        </div>
    `;
}

function togglePause() {
    state.paused = !state.paused;
    document.getElementById('pause-btn').textContent = state.paused ? '‚ñ∂Ô∏è' : '‚è∏Ô∏è';
    if (!state.paused) { lastTick = performance.now(); requestAnimationFrame(loop); }
}

// Spacebar pause/play shortcut
document.addEventListener('keydown', e => {
    if (e.code === 'Space' && state.match && state.match.status === 'live') {
        e.preventDefault();
        togglePause();
    }
});

function togglePanel(id) {
    document.getElementById(id).classList.toggle('collapsed');
}

function showVictoryCelebration(winnerTeam) {
    const m = state.match;
    // Find the winning king
    const winningKing = m.teams[winnerTeam].f.find(f => f.king && f.alive);
    
    if (winningKing) {
        // Show big trophy over king's head
        const el = fighterElements.get(winningKing.uid);
        if (el) {
            // Create trophy celebration element
            const trophy = document.createElement('div');
            trophy.className = 'victory-trophy';
            trophy.innerHTML = 'üèÜ';
            trophy.style.cssText = `
                position: absolute;
                left: ${winningKing.x}px;
                top: ${winningKing.y - 60}px;
                font-size: 48px;
                z-index: 999;
                animation: trophyBounce 0.5s ease-out infinite alternate;
                filter: drop-shadow(0 0 10px gold);
                pointer-events: none;
            `;
            document.getElementById('arena').appendChild(trophy);
            
            // Add cheering text
            const cheer = document.createElement('div');
            cheer.innerHTML = winnerTeam === 0 ? '‚öîÔ∏è VICTORY! ‚öîÔ∏è' : 'üíÄ DEFEATED üíÄ';
            cheer.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                font-family: 'Press Start 2P', monospace;
                font-size: 32px;
                color: ${winnerTeam === 0 ? '#32CD32' : '#DC143C'};
                text-shadow: 0 0 20px ${winnerTeam === 0 ? '#32CD32' : '#DC143C'}, 2px 2px 0 #000;
                z-index: 998;
                animation: cheerPulse 0.3s ease-in-out infinite alternate;
                pointer-events: none;
            `;
            document.body.appendChild(cheer);
            
            // Clean up after delay
            setTimeout(() => {
                trophy.remove();
                cheer.remove();
            }, 3800);
        }
    }
    
    // Log the victory
    const teamName = m.teamNames?.[winnerTeam] || (winnerTeam === 0 ? 'Allies' : 'Enemy');
    addLog(`üèÜ ${teamName} claims victory!`, winnerTeam === 0 ? '#32CD32' : '#DC143C');
}

function showResult() {
    const m = state.match;
    const won = m.winner === 0;
    if (won) state.wins++; else state.losses++;
    
    const t = document.getElementById('result-title');
    t.textContent = won ? 'üèÜ VICTORY!' : 'üíÄ DEFEAT';
    t.className = `result-title ${won ? 'win' : 'lose'}`;
    
    const a0 = m.teams[0].f.filter(f=>f.alive).length;
    const a1 = m.teams[1].f.filter(f=>f.alive).length;
    const yourName = m.teamNames?.[0] || 'Your Army';
    const enemyName = m.teamNames?.[1] || 'Enemy';
    document.getElementById('result-stats').innerHTML = `${yourName}: ${a0} | ${enemyName}: ${a1}<br>Your King: ${m.teams[0].kingAlive?'üëë Alive':'üíÄ Fallen'}<br>Record: ${state.wins}W / ${state.losses}L`;
    
    // Legends
    const all = getAllFighters(m);
    const awards = [
        {t:'üèÜ MVP', fn:f=>f.dmgDone, l:'DMG'},
        {t:'üíÄ KILLER', fn:f=>f.kills, l:'KILLS'},
        {t:'üõ°Ô∏è TANK', fn:f=>f.dmgTaken, l:'TANKED'},
        {t:'üíö HEALER', fn:f=>f.healDone, l:'HEALED'},
    ];
    const used = new Set();
    const legends = [];
    awards.forEach((a,i) => {
        const cands = all.filter(f=>!used.has(f.uid) && a.fn(f) > 0);
        if (!cands.length) return;
        cands.sort((x,y)=>a.fn(y)-a.fn(x));
        const w = cands[0];
        used.add(w.uid);
        legends.push({...w, award:a.t, label:a.l, val:a.fn(w), mvp:i===0});
    });
    
    document.getElementById('legends').innerHTML = legends.length ? `
        <div class="legends-title">‚öîÔ∏è LEGENDS ‚öîÔ∏è</div>
        <div class="legends-grid">${legends.map(l=>`
            <div class="legend-card${l.mvp?' mvp':''}">
                <div class="legend-tooltip">
                    <div class="legend-tooltip-name">${l.king ? (l.rankIcon || 'üëë') + ' ' : ''}${l.name}</div>
                    <div class="legend-tooltip-role">${l.role} ‚Ä¢ ${l.team===0?'ALLY':'ENEMY'}</div>
                    <div class="legend-tooltip-stats">
                        <div class="legend-tooltip-stat"><span>‚ù§Ô∏è HP</span> <b>${l.hp}/${l.maxHp}</b></div>
                        <div class="legend-tooltip-stat"><span>‚öîÔ∏è ATK</span> <b>${l.atk}</b></div>
                        <div class="legend-tooltip-stat"><span>üõ°Ô∏è DEF</span> <b>${l.def}</b></div>
                        <div class="legend-tooltip-stat"><span>üí® SPD</span> <b>${l.spd.toFixed(2)}</b></div>
                        <div class="legend-tooltip-stat"><span>üíÄ Kills</span> <b>${l.kills}</b></div>
                        <div class="legend-tooltip-stat"><span>üí• Dmg</span> <b>${l.dmgDone}</b></div>
                        <div class="legend-tooltip-stat"><span>ü©∏ Taken</span> <b>${l.dmgTaken}</b></div>
                        <div class="legend-tooltip-stat"><span>üíö Healed</span> <b>${l.healDone}</b></div>
                    </div>
                </div>
                <div class="legend-img"><img src="${getSpriteUrl(l)}" style="image-rendering:pixelated"></div>
                <div class="legend-name">${l.name}</div>
                <div class="legend-award">${l.award}</div>
                <div class="legend-stat">${l.val} ${l.label}</div>
            </div>
        `).join('')}</div>
    ` : '';
    
    // ==========================================
    // BATTLE STORY GENERATOR
    // ==========================================
    const story = generateBattleStory(m, legends, won);
    let storyEl = document.getElementById('battle-story');
    if (!storyEl) {
        storyEl = document.createElement('div');
        storyEl.id = 'battle-story';
        storyEl.style.cssText = 'margin:15px auto;max-width:500px;padding:15px;background:rgba(20,10,0,0.9);border:2px solid #8B4513;border-radius:8px;font-size:11px;line-height:1.6;color:#d4af37;font-style:italic;text-align:justify;';
        document.getElementById('result').appendChild(storyEl);
    }
    storyEl.innerHTML = `<div style="text-align:center;font-weight:bold;color:#FFD700;margin-bottom:10px;font-style:normal;">üìú THE ANNALS üìú</div>${story}`;
    
    document.getElementById('result').classList.add('active');
}

// Generate epic battle story from the match data - pulls from actual battle log
function generateBattleStory(m, legends, won) {
    const title = m.battleTitle || 'The Battle';
    const mvp = legends.find(l => l.mvp);
    const killer = legends.find(l => l.award === 'üíÄ KILLER');
    const tank = legends.find(l => l.award === 'üõ°Ô∏è TANK');
    const healer = legends.find(l => l.award === 'üíö HEALER');
    
    const t0Alive = m.teams[0].f.filter(f=>f.alive).length;
    const t1Alive = m.teams[1].f.filter(f=>f.alive).length;
    const t0Dead = m.teams[0].f.filter(f=>!f.alive).length;
    const t1Dead = m.teams[1].f.filter(f=>!f.alive).length;
    const totalDead = t0Dead + t1Dead;
    
    // Parse battle log for highlights
    const battleLog = m.battleLog || [];
    const crits = battleLog.filter(e => e.type === 'crit' || e.txt.includes('CRITICAL'));
    const rallies = battleLog.filter(e => e.type === 'rally' || e.txt.includes('rallies'));
    const resurrects = battleLog.filter(e => e.txt.toLowerCase().includes('resurrect') || e.txt.includes('rises from'));
    const routs = battleLog.filter(e => e.type === 'rout' || e.txt.includes('rout') || e.txt.includes('surrender'));
    const kingEvents = battleLog.filter(e => e.type === 'king' || e.txt.includes('King') || e.txt.includes('leader'));
    const backstabs = battleLog.filter(e => e.txt.includes('backstab') || e.txt.includes('Backstab'));
    const magicEvents = battleLog.filter(e => e.type === 'magic');
    
    // Check for special conditions
    const hadNecro = m.teams[0].f.concat(m.teams[1].f).some(f => f.role === 'Necromancer');
    const hadRaise = resurrects.length > 0;
    const kingFell = !m.teams[0].kingAlive || !m.teams[1].kingAlive;
    const bothKingsFell = !m.teams[0].kingAlive && !m.teams[1].kingAlive;
    const hadSurrender = routs.some(e => e.txt.includes('surrender'));
    const closeMatch = Math.abs(t0Alive - t1Alive) <= 2 && t0Alive > 0 && t1Alive > 0;
    const massacre = (won && t1Alive === 0) || (!won && t0Alive === 0);
    const hadBackstab = backstabs.length > 0;
    const epicRally = rallies.length >= 2;
    
    // Build the story with vivid prose
    let story = '';
    
    // Opening - vary sentence structure
    const openings = [
        `In ${title}, two armies clashed beneath a blood-red sky.`,
        `${title} began with the thunder of war drums and the clash of steel.`,
        `When the horns sounded at ${title}, none could foresee the carnage to come.`,
        `The savage pit trembled as ${title} erupted into chaos.`,
        `History would remember ${title} as a day of legends and loss.`,
    ];
    story += openings[Math.floor(Math.random() * openings.length)] + ' ';
    
    // Main narrative based on battle flow
    if (massacre) {
        story += won 
            ? `What followed was a rout of devastating proportions‚Äîthe enemy crumbled, their lines shattered beyond recovery. `
            : `Our forces were overwhelmed, falling one by one until none remained standing. `;
    } else if (closeMatch) {
        story += `The battle swayed like a pendulum, each side seizing momentum only to lose it again. `;
    } else {
        story += `Steel met steel as warriors surged across the bloodied ground, neither side willing to yield. `;
    }
    
    // Pull specific highlights from log
    if (crits.length > 0) {
        const critEvent = crits[Math.floor(Math.random() * crits.length)];
        // Extract names from the crit log if possible
        const critMatch = critEvent.txt.match(/(\w+)'s/);
        if (critMatch) {
            story += `${critMatch[1]}'s devastating critical strike sent shockwaves through the enemy ranks. `;
        } else {
            story += `A critical blow turned the tide at a pivotal moment. `;
        }
    }
    
    // MVP highlight with more flair
    if (mvp) {
        const mvpPhrases = [
            `${mvp.name} carved a bloody path through the chaos, dealing ${mvp.val} damage and etching their name into legend.`,
            `The warrior ${mvp.name} proved unstoppable, their ${mvp.val} damage defining the battle's outcome.`,
            `${mvp.name} emerged as the battle's champion, leaving ${mvp.val} damage in their wake.`,
        ];
        story += mvpPhrases[Math.floor(Math.random() * mvpPhrases.length)] + ' ';
    }
    
    // Resurrection events (from necromancers)
    if (hadRaise) {
        story += `Dark magic pulsed across the field as the dead stirred‚Äîfallen warriors rising to fight once more, their eyes hollow but their blades still sharp. `;
    }
    
    // Rally events
    if (epicRally) {
        story += `Against all odds, a rallying cry echoed through the ranks, turning despair into defiance. `;
    } else if (rallies.length === 1) {
        story += `A desperate rally momentarily shifted the battle's momentum. `;
    }
    
    // Backstab events (rogues)
    if (hadBackstab) {
        story += `From the shadows, a rogue's blade found its mark‚Äîa decisive backstab that shattered the enemy's confidence. `;
    }
    
    // King events
    if (bothKingsFell) {
        story += `Both commanders fell in the fray, their deaths leaving armies leaderless and reeling. `;
    } else if (kingFell) {
        story += won 
            ? `The enemy's leader fell with a final, defiant cry, and with them, all hope of victory. `
            : `Our king's banner crumpled to the ground, a blow from which morale could not recover. `;
    }
    
    // Surrender events
    if (hadSurrender) {
        story += `In the end, the survivors threw down their arms, pledging fealty to the victors to save their lives. `;
    }
    
    // Closing - vivid and varied
    const closings = won ? [
        `Victory was claimed, though ${t0Dead} brave souls paid the ultimate price. Their sacrifice will not be forgotten.`,
        `The field belonged to the victors, their triumph forged in blood and iron. ${t0Dead} fell so that others might stand.`,
        `When silence finally fell, victory was ours‚Äîcostly, brutal, but undeniable.`,
    ] : [
        `Defeat came not from cowardice, but from the cruel mathematics of war. ${t0Alive} survivors will carry the memory forward.`,
        `We fell, but not without honor. The ${t0Alive} who remain will rebuild, and remember.`,
        `The battle was lost, but the spirit of the fallen will echo through the ages.`,
    ];
    story += closings[Math.floor(Math.random() * closings.length)];
    
    return story;
}

// Draggable panels
document.querySelectorAll('.panel-header').forEach(h => {
    h.onmousedown = e => {
        if (e.target.classList.contains('panel-btn')) return;
        const panel = h.parentElement;
        const rect = panel.getBoundingClientRect();
        const ox = e.clientX - rect.left, oy = e.clientY - rect.top;
        const move = e => {
            panel.style.left = (e.clientX - ox) + 'px';
            panel.style.top = (e.clientY - oy) + 'px';
            panel.style.right = 'auto';
        };
        const up = () => { document.removeEventListener('mousemove', move); document.removeEventListener('mouseup', up); };
        document.addEventListener('mousemove', move);
        document.addEventListener('mouseup', up);
    };
});

// Initialize - try to load from JSON, then shuffle roster
(async function init() {
    await loadRosterFromJSON();
    // Preload NFT metadata in background
    loadNFTMetadata().then(() => console.log('üì¶ NFT metadata ready'));
    // Initial shuffle for variety
    shuffleRoster();
    // Check if wallet already connected (page refresh)
    if (window.ethereum && window.ethereum.selectedAddress) {
        walletState.address = window.ethereum.selectedAddress;
        walletState.connected = true;
        updateWalletUI();
        loadOwnedNFTs();
    }
    console.log('‚öîÔ∏è Savage Arena initialized!');
})();
</script>
<script src="pfp-generator.js"></script>
</body>
</html>
